{"meta":{"title":"学而知码，写而造轮","subtitle":null,"description":null,"author":"WXY","url":"http://wxy-cs.com"},"pages":[{"title":"weixin","date":"2016-10-03T10:45:17.000Z","updated":"2016-10-03T10:48:24.110Z","comments":true,"path":"weixin/index.html","permalink":"http://wxy-cs.com/weixin/index.html","excerpt":"","text":"请扫一扫，添加微信"},{"title":"Categories","date":"2016-10-03T06:44:28.609Z","updated":"2016-09-19T14:18:54.000Z","comments":true,"path":"categories/index.html","permalink":"http://wxy-cs.com/categories/index.html","excerpt":"","text":""},{"title":"About this web site","date":"2016-10-13T12:40:41.356Z","updated":"2016-10-13T12:40:41.352Z","comments":true,"path":"about/index.html","permalink":"http://wxy-cs.com/about/index.html","excerpt":"","text":"姓名: 王小猿 造不好轮子，撸不好代码的程序猿!"},{"title":"Tags","date":"2016-10-03T06:44:28.609Z","updated":"2016-09-19T14:18:54.000Z","comments":true,"path":"tags/index.html","permalink":"http://wxy-cs.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"苏格拉底三段论","slug":"苏格拉底三段论","date":"2017-01-07T02:14:01.000Z","updated":"2017-01-07T02:28:45.111Z","comments":true,"path":"2017/01/07/苏格拉底三段论/","link":"","permalink":"http://wxy-cs.com/2017/01/07/苏格拉底三段论/","excerpt":"","text":"苏格拉底三段论 所有人都是要死的 苏格拉底是人 所以苏格拉底是要死的 命题推理 P:所有人都是要死的 Q:苏格拉底是人 R:所以苏格拉底是要死的 P^Q→R 当P和Q都为1时，R为0时，P^Q→R为0，我们一般认为是正确的。但是根据命题逻辑，这却是错误的。所以无法用命题逻辑进行表示。 由于原子命题是命题中的最小单位，无法再分，所以无法考虑命题间的内在联系和数量关系。 ### 例子“所有人都是要死的”和“苏格拉底是要死的”，这两个命题是有联系的，它俩都表示“ｘ是要死的”这个性质。在命题逻辑中却需要两个命题表示。 结论使用一阶谓词逻辑","categories":[],"tags":[{"name":"离散数学","slug":"离散数学","permalink":"http://wxy-cs.com/tags/离散数学/"}],"keywords":[]},{"title":"2017","slug":"2017","date":"2016-12-31T15:05:42.000Z","updated":"2016-12-31T15:07:45.357Z","comments":true,"path":"2016/12/31/2017/","link":"","permalink":"http://wxy-cs.com/2016/12/31/2017/","excerpt":"","text":"linux 内核源码 一个小型编译器 leetcode 算法","categories":[],"tags":[{"name":"计划","slug":"计划","permalink":"http://wxy-cs.com/tags/计划/"}],"keywords":[]},{"title":"汉诺塔问题详解","slug":"汉诺塔问题详解","date":"2016-12-27T01:55:36.000Z","updated":"2016-12-27T02:15:48.125Z","comments":true,"path":"2016/12/27/汉诺塔问题详解/","link":"","permalink":"http://wxy-cs.com/2016/12/27/汉诺塔问题详解/","excerpt":"","text":"问题说明问题出自古印度（一说西藏）。某神庙有三根细柱，64个大小不等、中心有孔的金盘套在柱上，构成梵塔。僧侣日夜不息地将圆盘从一柱移到另一柱，规则是每次只移一个盘，大盘不能放到小盘上。开始时圆盘从大到小套在一根柱上，据说所有圆盘都搬到另一根柱时世界就要毁灭。 规则说明设a,b,c是3个塔座。开始时，在塔座a上有一叠共n个圆盘，这些圆盘自下而上，由大到小地叠在一起。各圆盘从小到大编号为1,2,…,n,现要求将塔座a上的这一叠圆盘移到塔座b上，并仍按同样顺序叠置。在移动圆盘时应遵守以下移动规则：规则1：每次只能移动1个圆盘；规则2：任何时刻都不允许将较大的圆盘压在较小的圆盘之上；规则3：在满足移动规则1和2的前提下，可将圆盘移至a,b,c中任一塔座上 ## 问题分析 if n == 1 直接将盘子从ａ移动到ｃ即可 if n == 2 if n== 3 文字分析 if n== 1 setp1:a–&gt;c if n == 2 setp:1 a–&gt;b setp:2 a–&gt;c setp3: b–&gt;c if n == 3 setp1:a–&gt;b a--&gt;b setp2:a–&gt;c setp3:b–&gt;c b--&gt;c 总结可得，都是经过三个步骤： 1.mov a to b (前n-1个盘子) 2.mov a to c (最后一个大盘子) 3.mov b to c (前n-1个盘子) 可以看出步骤１和步骤２移动的原理和盘子数是相同的所以可以归纳出： H(n)=2*H(n-1) + 1 (1 为移动最大盘子的次数)上面的式子已经形成了一个递归试。 说明 当进行第n-1次移动时，无论如何移动，这n-1个盘子都要比上一次递归的那个最大的盘子要小，所以就可以抽象的忽略那个最大的盘子，来进行移动这个n-1个盘子。 TODO1.代码分析 2.配图转移到图床","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://wxy-cs.com/tags/算法/"}],"keywords":[]},{"title":"整数划分","slug":"整数划分","date":"2016-12-27T01:20:14.000Z","updated":"2016-12-27T01:35:44.873Z","comments":true,"path":"2016/12/27/整数划分/","link":"","permalink":"http://wxy-cs.com/2016/12/27/整数划分/","excerpt":"","text":"整数划分问题是将一个整数n划分成： n=m1+m2+m3……mi 满足的条件为： 1&lt;=mi&lt;=n 如果MAX{m1,m2……mi}&lt;=m ,就称它是属于n的一个m划分。 设f(n,m) 为整数n的m划分的分数。 分析： 1.如果m=1,划分即为{1,1,1……1}, f(n,m)=1 2.如果n=1,划分即为{1}， f(n,m)=1 3.如果n=m (1)包含n的时候，划分即为{n} ,f(n,n)=1 (2)不包含n的时候，f(n,n)=f(n,n-1) //递归查看n的n-1划分 所以f(n,n)=1 + f(n,n-1) 4.如果n&lt;m,不可能有负数，所以即为f(n,n) 5.如果n&gt;m (1)包含m的时候，划分即为{m,{x1,x2…..xi}},x1+x2+……xi=n-m, f(n,m)=f(n-m,m) (2)不包含m的时候，f(n,m)=f(n,m-1) 所以f(n,m)=f(n-m,m) + f(n,m-1) TODO代码分析","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://wxy-cs.com/tags/算法/"}],"keywords":[]},{"title":"单片机读取锁存器还是引脚问题","slug":"单片机读取锁存器还是引脚问题","date":"2016-12-25T15:28:43.000Z","updated":"2016-12-25T15:29:39.908Z","comments":true,"path":"2016/12/25/单片机读取锁存器还是引脚问题/","link":"","permalink":"http://wxy-cs.com/2016/12/25/单片机读取锁存器还是引脚问题/","excerpt":"","text":"","categories":[{"name":"技术","slug":"技术","permalink":"http://wxy-cs.com/categories/技术/"}],"tags":[{"name":"单片机","slug":"单片机","permalink":"http://wxy-cs.com/tags/单片机/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://wxy-cs.com/categories/技术/"}]},{"title":"OSPF 协议详解","slug":"OSPF-协议详解","date":"2016-11-16T04:25:36.000Z","updated":"2016-11-16T04:58:36.523Z","comments":true,"path":"2016/11/16/OSPF-协议详解/","link":"","permalink":"http://wxy-cs.com/2016/11/16/OSPF-协议详解/","excerpt":"","text":"","categories":[{"name":"技术","slug":"技术","permalink":"http://wxy-cs.com/categories/技术/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://wxy-cs.com/tags/计算机网络/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://wxy-cs.com/categories/技术/"}]},{"title":"RIP-坏消息传的慢","slug":"RIP-坏消息传的慢","date":"2016-11-16T04:25:22.000Z","updated":"2016-11-16T05:35:11.371Z","comments":true,"path":"2016/11/16/RIP-坏消息传的慢/","link":"","permalink":"http://wxy-cs.com/2016/11/16/RIP-坏消息传的慢/","excerpt":"","text":"RIP特点RIP协议的特点是：实现简单，开销小。但有“坏消息传的慢”，只适应较小规模的网络（最多14个路由器）。 “坏消息传的慢”在某一线路或网络突然出现故障，不能通讯时，有可能(可能性很大)出现坏消息传的慢问题。","categories":[{"name":"技术","slug":"技术","permalink":"http://wxy-cs.com/categories/技术/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://wxy-cs.com/tags/计算机网络/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://wxy-cs.com/categories/技术/"}]},{"title":"分支限界法","slug":"分支限界法","date":"2016-11-14T09:24:55.000Z","updated":"2016-11-16T05:01:41.659Z","comments":true,"path":"2016/11/14/分支限界法/","link":"","permalink":"http://wxy-cs.com/2016/11/14/分支限界法/","excerpt":"","text":"","categories":[{"name":"技术","slug":"技术","permalink":"http://wxy-cs.com/categories/技术/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://wxy-cs.com/tags/算法/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://wxy-cs.com/categories/技术/"}]},{"title":"划分子网-子网号问题","slug":"划分子网-子网号问题","date":"2016-11-14T06:48:16.000Z","updated":"2016-11-14T08:45:50.849Z","comments":true,"path":"2016/11/14/划分子网-子网号问题/","link":"","permalink":"http://wxy-cs.com/2016/11/14/划分子网-子网号问题/","excerpt":"","text":"子网号在划分子网时会出现是否保留全零全一的子网号问题。 1.主机号全零全一一定要保留（全零为本网络，全一为广播地址）。 2.旧的网络协议是要保留全零全一的子网号，但是新的网络协议就不需要保留了！","categories":[{"name":"技术","slug":"技术","permalink":"http://wxy-cs.com/categories/技术/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://wxy-cs.com/tags/计算机网络/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://wxy-cs.com/categories/技术/"}]},{"title":"RIP协议详解","slug":"RIP协议详解","date":"2016-11-07T05:49:39.000Z","updated":"2016-11-14T08:48:52.780Z","comments":true,"path":"2016/11/07/RIP协议详解/","link":"","permalink":"http://wxy-cs.com/2016/11/07/RIP协议详解/","excerpt":"","text":"路由选择算法路由选择算法是计算机网络的核心部分，分为两类： 静态路由选择策略 动态路由选择策略 静态路由选择策略静态略有选择策略是人工进行配置路由表,特点是：不具有自适应性，不能及时适应网络状态的变化，但是简单，开销较小。 配置命令: 1234一、Router(config)# ip route destination_network_# [subnet_mask] IP_address_of_next_hop_neighbor [administrative_distance] [permanent]二、Router(config)# ip route destination_network_# [subnet_mask] interface_to_exit [administrative_distance] [permanent] 动态路由选择策略动态路由选择策略是路由器进行自适应配置路由表，特点是:具有良好的自适应性，能及时适应网络状态的变化，但是较为复杂，而且开销较大。 自治系统(AS) 由于互联网越来越大，路由器里的路由表也随之变大，早期路由表里存放着到达每一个网络的下一跳地址，但是路由表依旧很大，同时许多单位不愿意对外公开自己内部的网络拓扑结构，于是人们又对互联网再次进行了划分，将互联网划分成一个一个的自治系统，一个自治系统其实就是一个小的互联网，自治系统也可以说是单一的技术管理下的一组路由器,每一个自治系统由几个网络组成。 在现在的互联网上一个大的ISP就是一个自治系统。 一个自治系统内部需要确定一种路由选择协议（IGP），以确定分组在自治系统内部的路由，同时也需要一个外部的路由协议（EGP），以确定分组在AS之间的路由。 自治系统之间的路由选择又称为:域间路由选择，而自治系统内部的路由选择又称为:域内路由选择。IGP和EGP是一种协议类型，不是一种协议IGP(Interior Gateway Protocol)内部网关协议 面对的是一个个网络的路由器典型协议: RIP(Routing Infaction Protocol) 路由信息协议 OSPF(Open Shortest Path First)开放式最短路径优先协议EGP(Exterior Gateway Protocol)外部网关协议 面对的是一个个的小互联网的边界路由典型协议: BGP(Border Gateway Protocol) 边界网关协议 RIP 原理：基于距离向量的内部网关协议。通过本地广播定期的(系统默认是30s)向相邻的路由器交换路由信息，通过距离向量来选择一条最优的线路(通过“跳数”来计算距离，初始相邻的网络跳数为1，每跨过一个路由器，跳数自动加一，但最多跨15个路由器，当跳数为16时就代表网络不可达(以后的直接相连的网络跳数不加一))。 距离向量算法 对于来自相邻路由X的路由信息，先将下一条地址改为X，然后将跳数加一。 路由表里每一行都有三个项目:到达的网络N,距离是d，下一条路由器是X。 步骤： 1234567if(路由表里没有到达这网络的路由信息) 添加 else if(到达该网络的下一条路由器为X) 替换 else 比较两条路由信息，保留距离较短的那条路由信息。 若在三分钟内还没有收到相邻路由的更新路由信息，就将该路由标记为不可到达，即将距离改为16。","categories":[{"name":"技术","slug":"技术","permalink":"http://wxy-cs.com/categories/技术/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://wxy-cs.com/tags/计算机网络/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://wxy-cs.com/categories/技术/"}]},{"title":"VLAN 详解","slug":"VLAN-详解","date":"2016-11-03T10:59:50.000Z","updated":"2016-11-03T11:34:18.662Z","comments":true,"path":"2016/11/03/VLAN-详解/","link":"","permalink":"http://wxy-cs.com/2016/11/03/VLAN-详解/","excerpt":"","text":"写的非常不错图文并茂VLAN全接触(完整版)","categories":[{"name":"技术","slug":"技术","permalink":"http://wxy-cs.com/categories/技术/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://wxy-cs.com/tags/计算机网络/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://wxy-cs.com/categories/技术/"}]},{"title":"traceroute工作原理","slug":"traceroute工作原理","date":"2016-11-02T04:42:31.000Z","updated":"2016-11-03T12:04:31.051Z","comments":true,"path":"2016/11/02/traceroute工作原理/","link":"","permalink":"http://wxy-cs.com/2016/11/02/traceroute工作原理/","excerpt":"","text":"##ICMPICMP协议称为网际控制报文协议，ICMP协议分为两大类：1.差错报告报文 2.询问报文 ###差错报告报文 类型 类型的值 终点不可达 3 原点抑制 4 时间超过 11 参数问题 12 改变路由 5 ###询问报文 类型 类型的值 回送请求或回答 0或8 时间戳请求或回答 13或14 traceroute命令使用了ICMP协议的时间超过和终点不可达两种： 首先源主机发送一个TTL为1的IP数据报。 每次发送比上一次TTL加一的IP数据报。 所以没到达目的主机前，最后一个路由都会回送一个时间超出的ICMP协议的数据包(封装在一个IP数据报里，所以源主机可以获取到该路由器的IP地址)。 源主机每次发送的IP数据报都是封装一个端口不可达(目的端口号使用目的主机尾未使用的端口号)的UDP数据报文。 这样当源主机发送的IP数据报到达目的主机时，就不会回传时间超过的ICMP报文，而是回送终点不可达ICMP报文，这样源主机就可以知道到达目的主机所要经过的路由器。","categories":[{"name":"技术","slug":"技术","permalink":"http://wxy-cs.com/categories/技术/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://wxy-cs.com/tags/计算机网络/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://wxy-cs.com/categories/技术/"}]},{"title":"可重入函数","slug":"可重入函数","date":"2016-11-01T07:09:23.000Z","updated":"2016-11-02T00:24:09.406Z","comments":true,"path":"2016/11/01/可重入函数/","link":"","permalink":"http://wxy-cs.com/2016/11/01/可重入函数/","excerpt":"","text":"In computing, a computer program or subroutine is called reentrant if it can be interrupted in the middle of its execution, and then be safely called again (“re-entered”) before its previous invocations complete execution. The interruption could be caused by an internal action such as a jump or call, or by an external action such as a hardware interrupt or signal. Once the reentered invocation completes, the previous invocations will resume correct execution. This definition originates from single-threaded programming environments where the flow of control could be interrupted by a hardware interrupt and transferred to an interrupt service routine (ISR). Any subroutine used by the ISR that could potentially have been executing when the interrupt was triggered should be reentrant. Often, subroutines accessible via the operating system kernel are not reentrant. Hence, interrupt service routines are limited in the actions they can perform; for instance, they are usually restricted from accessing the file system and sometimes even from allocating memory. A subroutine that is directly or indirectly recursive should be reentrant. This policy is partially enforced by structured programming languages.[citation needed] However a subroutine can fail to be reentrant if it relies on a global variable to remain unchanged but that variable is modified when the subroutine is recursively invoked. This definition of reentrancy differs from that of thread-safety in multi-threaded environments. A reentrant subroutine can achieve thread-safety,[1] but being reentrant alone might not be sufficient to be thread-safe in all situations. Conversely, thread-safe code does not necessarily have to be reentrant (see below for examples). Other terms used for reentrant programs include “pure procedure” or “sharable code” 以上是来自维基百科的介绍。大意是：在计算机里，程序或子程序在执行期间可被中断，然后在以前调用执行完成的情况下可再次被安全的调用叫做可重入，中断可以是内部事件引起的如跳转或调用,或外部事件如硬件中断或信号引起的。一旦再次调用完成，以前的调用依旧能正确的执行。这种定义来源于单线程编程环境中控制流可以被硬件中断给中断然后转移去中断服务子程序。任何被ISR使用的子程序在中断被触发的时候","categories":[{"name":"技术","slug":"技术","permalink":"http://wxy-cs.com/categories/技术/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://wxy-cs.com/tags/操作系统/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://wxy-cs.com/categories/技术/"}]},{"title":"图的m着色问题","slug":"图的m着色问题","date":"2016-10-31T06:39:29.000Z","updated":"2016-10-31T08:04:34.339Z","comments":true,"path":"2016/10/31/图的m着色问题/","link":"","permalink":"http://wxy-cs.com/2016/10/31/图的m着色问题/","excerpt":"","text":"四色定理四色定理又称四色猜想、四色问题，是世界三大数学猜想之一。四色定理的本质许多人认为是在平面或者球面无法构造五个或者五个以上两两相连的区域。这个概念实际上是错误的，因为有许多种方法在代数几何上可以完美的证明任意一个区域无法同时与其他四个任意区域两两相连。但实际上证明的时候会把区域之间相互重叠的关系否定掉。其本质在与地图上是否可以只用四种颜色着色，从而演变出一个几何上的数学问题，但之所以至今只能用计算机暴力证明，其根源仍然无法得知，有诸多的猜想，但却仍然是一个无法以书面简单证明来完成的难题。 可平面图一个图G，将它画在一个平面上，如果图G各个边不相交，只相交于顶点，则称图G为可平面图。可平面图一般先把一个图转换成可平面图然后再进行研究着色问题。 着色问题国王遗嘱; 国王将国土分给五个儿子，五个儿子想各自立国，要求相互之间划清国界。 经四色定理可知，只需四种颜色即可将国界划分清楚。如下图： 图的m着色问题：要求在无向图中，为各个顶点着色，相邻顶点不能着相同的颜色,求最少的颜色数m，m也称做该图的色数。 回溯法解空间：设X[i] 为第i顶点的所着颜色，用1….m分别代表m种颜色，搜索空间为n元一维数组x[1],x[2]…..x[n]取值范围:(m^n)（1,1,1……1）…..(n,n,n……n)解空间如下;(3个顶点，3种颜色) 先定义一个邻接矩阵A(A[i][j]=1 代表节点i和节点j有线段相连)判定条件：A[i][j]==1 &amp;&amp; X[i]!=X[j] 即可往下深度搜索，否则进行回溯或剪枝。(i,j为父节点，子节点) 穷举法Welch Powell法 首先按各个节点的度从大到小排序（会出现度相同的节点，所以答案不唯一） 给第一个节点选一种颜色着上，然后从大到小(度数)寻找与它不相邻的节点涂上相同的颜色 然后再从头开始找未涂色节点，用另一种颜色，重复第二步,直到所有节点都涂上颜色为止 节点：1:红色 节点：2:绿色 节点：3:黄色 节点：4:黄色 节点：5:红色 节点：6:绿色 节点：7:绿色 节点：8:黄色 所以可以着三种颜色。 注：以上图片均来自网络，文章参考自网络，如有侵权请及时告知，24小时内删除！","categories":[{"name":"技术","slug":"技术","permalink":"http://wxy-cs.com/categories/技术/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://wxy-cs.com/tags/算法/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://wxy-cs.com/categories/技术/"}]},{"title":"文件系统","slug":"文件系统","date":"2016-10-30T11:02:03.000Z","updated":"2016-10-30T11:02:04.012Z","comments":true,"path":"2016/10/30/文件系统/","link":"","permalink":"http://wxy-cs.com/2016/10/30/文件系统/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"溢出标志位OF","slug":"溢出标志位OF","date":"2016-10-30T01:45:41.000Z","updated":"2016-10-31T06:39:25.517Z","comments":true,"path":"2016/10/30/溢出标志位OF/","link":"","permalink":"http://wxy-cs.com/2016/10/30/溢出标志位OF/","excerpt":"","text":"溢出的原意是在一个容器里，水满了会溢出来。而在计算机里指的是运算的数据超过CPU的字长所能表示的范围，寄存器无法表示这个数据。在计算机中溢出分为两种： 可修正溢出 不可修正溢出可修正溢出指的其实就是CF标志位。不可修正溢出指的其实是OF标志位。进位标志位CF表示的是无符号数进行运算是否超出运算范围，超出范围后再加上进位或借位标志位后结果仍然正确（即可修正）。而溢出标志位指的是有符号数之间进行运算是否超出范围，超出范围运算结果不正确（即不可修正）。从用户角度，参与运算的数据可以是有符号数或无符号数,而计算机无法进行判断是有符号数还是无符号数，所以计算机进行计算时，先按照无符号数运算置位CF，再按有符号数运算置位OF。在计算机中是通过异或门来进行置位OF标志位;最高位的进位与次高位的进位进行异或,也就是说如果最高位符号位产生进位，而次高位数值位没有产生进位，或最高位符号位没有产生进位，次高位数值位产生进位的话即发生溢出，要置位OF溢出标志位。eg:1234 0 1 0 0 0 0 0 0+ 0 1 1 0 0 0 0 0 -------------------- 1 0 1 0 0 0 0 0 CF=0 OF=1 12345 1 0 0 0 0 0 0 0+ 1 1 1 0 0 0 0 0 --------------------1 0 1 1 0 0 0 0 0 CF=0 OF=1结论:两个正数相加的结果位负数，或两个负数相加的结果为正数即发生了溢出。 溢出的根本原因是数据有符号后，表示范围发生了改变，像8位的无符号数的表示范围是0~255，而8位有符号数的表示范围变为-128~127，也就是说有一个数大于127或小于-128就发生了溢出。 应用1234setg D ~(SF^OF)&amp;~ZF→D 大于（有符号数）setge D ~(SF^OF)→D 大于等于(有符号数) setl D (SF^OF)→D 小于(有符号数)setle D (SF^OF)|ZF→D 小于等于(有符号数) 正数(大)-正数(小)=正数 SF=0 OF=0 ~(SF^OF)=1 ZF=0 ~(SF^OF)&amp;~ZF=1正数(小)-正数(大)=负数 SF=1 OF=0 (SF^OF)=1正数(大)+负数(小)=正数 SF=0 OF=0 或 SF=1 OF=1 ~(SF^OF)=1 ZF=0 ~(SF^OF)&amp;ZF=1正数(小)-负数(大)=正数 SF=0 OF=负数(大)-正数(小)=正数 SF=1 OF=负数(小)-正数(大)=正数 SF=0 OF=","categories":[],"tags":[{"name":"汇编","slug":"汇编","permalink":"http://wxy-cs.com/tags/汇编/"}],"keywords":[]},{"title":"git 版本控制","slug":"git-版本控制","date":"2016-10-17T14:17:46.000Z","updated":"2016-10-17T14:20:13.924Z","comments":true,"path":"2016/10/17/git-版本控制/","link":"","permalink":"http://wxy-cs.com/2016/10/17/git-版本控制/","excerpt":"","text":"git的学习记录","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://wxy-cs.com/tags/git/"}],"keywords":[]},{"title":"软件工程-整体开发过程记录","slug":"软件工程-整体开发过程记录","date":"2016-10-16T14:40:20.000Z","updated":"2016-10-16T14:45:35.530Z","comments":true,"path":"2016/10/16/软件工程-整体开发过程记录/","link":"","permalink":"http://wxy-cs.com/2016/10/16/软件工程-整体开发过程记录/","excerpt":"","text":"记录学习软件工程，开发一个小项目的全过程","categories":[],"tags":[{"name":"软件工程","slug":"软件工程","permalink":"http://wxy-cs.com/tags/软件工程/"}],"keywords":[]},{"title":"数据流图","slug":"数据流图","date":"2016-10-16T14:26:46.000Z","updated":"2016-10-16T14:26:46.389Z","comments":true,"path":"2016/10/16/数据流图/","link":"","permalink":"http://wxy-cs.com/2016/10/16/数据流图/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"装饰器","slug":"装饰器","date":"2016-10-14T14:29:30.000Z","updated":"2016-10-16T14:44:24.490Z","comments":true,"path":"2016/10/14/装饰器/","link":"","permalink":"http://wxy-cs.com/2016/10/14/装饰器/","excerpt":"","text":"装饰器是python里的重要语法.","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://wxy-cs.com/tags/python/"}],"keywords":[]},{"title":"闭包","slug":"闭包","date":"2016-10-14T13:42:58.000Z","updated":"2016-11-14T10:06:51.985Z","comments":true,"path":"2016/10/14/闭包/","link":"","permalink":"http://wxy-cs.com/2016/10/14/闭包/","excerpt":"","text":"1.python一切皆对象在python里所有的变量都是对象的引用123List=[1,2,3] # 列表Tuple=(2,3,4) # 元组Dict=&#123;'A':1,'B':2&#125; # 字典 1234567class Myclass: def __init__(self,name): self.name=name def work(): print name me=Myclass('xx') 2.函数是第一类对象第一类对象是指，该对象可以赋值给其它标识符，可以作为函数的参数，可以作为返回值返回。 函数赋值给其它标识符 (函数名是函数对象的引用)123def func(a,b): return a+badd=func 作为函数参数12345def func(f): return f()def f(): print 1+1 作为返回值123456def f(a,b): return a*bdef func(f): return f(1,1)print func(f) 函数对象与函数调用1234567def func(): return \"hello,word!\"t1=funct2=func()print type(t1) #functionprint type(t2) #str t1是函数对象赋值t2是函数调用返回值的赋值 闭包含义闭包就是保存代码和代码(python里是以函数来体现的)的上下文环境，将其打包为一个对象(包含环境变量)。是函数式编程的重要语法。例一1234567891011def func(): x=1 def inner_func(): return x return inner_funcx=2f1=func()print f1()#执行结果：&gt;&gt;&gt;1 inner_func 函数保存了前一层嵌套函数的ｘ 例二12345678def func(a,b): def f(x): return a*x+bf1=func(1,2)f2=func(2,3)f1(5)f2(6) ｆ函数保存了上一层嵌套函数的参数里的ａ,ｂ 命名空间（作用域）在ｃ语言中不同模块的相同名字的变量有时会发生冲突，所以在ｃ++中引入namespace，在python中也存在命名空间。在不同命名空间中，可以区分相同名字的变量在python中因为一切皆为对象，所以变量名称都是对对象的引用，所以python的命名空间就是一个字典，在字典里存着变量名和对象的映射关系。因此python解释器查找变量名就是在命名空间中查找键值对,那么按照啥顺序在不同的命名空间里查找那？这就引出了LEGB法则 LEGB法则L–Local 函数内的命名空间E–Enclosing function locals 外边嵌套的函数的命名空间G–Global 本模块内的命名空间B–Builtin python内置模块的命名空间 LEGB就是用来规定查找命名空间顺序的！","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://wxy-cs.com/tags/python/"}],"keywords":[]},{"title":"尾递归","slug":"尾递归","date":"2016-10-13T11:32:54.000Z","updated":"2016-10-13T12:36:11.003Z","comments":true,"path":"2016/10/13/尾递归/","link":"","permalink":"http://wxy-cs.com/2016/10/13/尾递归/","excerpt":"","text":"简介尾递归与普通递归的差别在于对内存的使用量，普通递归创建堆栈，占用内存空间先增加后而收缩，尾递归对内存的使用一直保持恒定。 实例12345(普通递归版)def add(n): if n==1: return n return n + add(n-1) 运算过程(当n初始值为６)123456789101112add(6)6 + add(5)6 + (5 + add(4))6 + (5 + (4 + add(3)))6 + (5 + (4 + (3 + add(2))))6 + (5 + (4 + (3 + (2 + add(1)))))6 + (5 + (4 + (3 + (2 + 1))))6 + (5 + (4 + (3 + 3)))6 + (5 + (4 + 6))6 + (5 + 10)6 + 1521 使用尾递归1234def add(n,num=0): if n==1 return num return add(n-1,n+num) 运算过程(当n的初始值为６) 1234567add(6,0)add(5,6)add(4,11)add(3,15)add(2,18)add(1,20)21 原理 保证返回的是一个纯函数 尾递归的判断标准是函数运行最后一步是否调用自身，而不是是否在函数的最后一行调用自身。 参考链接 尾调用优化","categories":[{"name":"技术","slug":"技术","permalink":"http://wxy-cs.com/categories/技术/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"http://wxy-cs.com/tags/技巧/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://wxy-cs.com/categories/技术/"}]},{"title":"动态规划：金矿模型","slug":"动态规划：金矿模型","date":"2016-10-13T04:18:51.000Z","updated":"2016-10-13T04:58:15.109Z","comments":true,"path":"2016/10/13/动态规划：金矿模型/","link":"","permalink":"http://wxy-cs.com/2016/10/13/动态规划：金矿模型/","excerpt":"","text":"动态规划一直不好理解，直到看到这个金矿模型。 介绍从前有个小国，小国有个聪明的国王，有一天在这个国家发现了１０个金矿，国王非常高兴，于是决定组织人员进行挖掘，来造福人民。首先他把这些金矿按照在地图上的位置从西至东进行编号，依次为0、1、2、3、4、5、6、7、8、9，然后他命令他的手下去对每一座金矿进行勘测，以便知道挖取每一座金矿需要多少人力以及每座金矿能够挖出多少金子，然后动员国民都来挖金子。 限制条件 挖每一座金矿需要的人数是固定的，多一个人少一个人都不行。国王知道每个金矿各需要多少人手，金矿i需要的人数为peopleNeeded[i]。 每一座金矿所挖出来的金子数是固定的，当第i座金矿有peopleNeeded[i]人去挖的话，就一定能恰好挖出gold[i]个金子。否则一个金子都挖不出来。 开采一座金矿的人完成开采工作后，他们不会再次去开采其它金矿，因此一个人最多只能使用一次。 国王在全国范围内仅招募到了10000名愿意为了国家去挖金子的人，因此这些人可能不够把所有的金子都挖出来，但是国王希望挖到的金子越多越好。 这个国家的每一个人都很老实（包括国王），不会私吞任何金子，也不会弄虚作假，不会说谎话。 有很多人拿到这个题后的第一反应就是对每一个金矿求出平均每个人能挖出多少金子，然后从高到低进行选择，这里要强调这种方法是错的，如果你也是这样想的，请考虑背包模型，当有一个背包的容量为10，共有3个物品，体积分别是3、3、5，价值分别是6、6、9，那么你的方法取到的是前两个物品，总价值是12，但明显最大值是后两个物品组成的15。 我们只需要知道最多可以挖出多少金子即可，而不用关心哪些金矿挖哪些金矿不挖。 那么，国王究竟如何知道在只有10000个人的情况下最多能挖出多少金子呢？国王是如何思考这个问题的呢？ 国王首先来到了第9个金矿的所在地（注意，第9个就是最后一个，因为是从0开始编号的，最西边的那个金矿是第0个），他的臣子告诉他，如果要挖取第9个金矿的话就需要1500个人，并且第9个金矿可以挖出8888个金子。听到这里国王哈哈大笑起来，因为原先他以为要知道十个金矿在仅有10000个人的情况下最多能挖出多少金子是一件很难思考的问题，但是，就在刚才听完他的臣子所说的那句话时，国王已经知道总共最多能挖出多少金子了，国王是如何在不了解其它金矿的情况下知道最多能挖出多少金子的呢？他的臣子们也不知道这个谜，因此他的臣子们就问他了：“最聪明的国王陛下，我们都没有告诉您其它金矿的情况，您是如何知道最终答案的呢？” 得意的国王笑了笑，然后把他最得意的“左、右手”叫到跟前，说到：“我并不需要考虑最终要挖哪些金矿才能得到最多的金子，我只需要考虑我面前的这座金矿就可以了，对于我面前的这座金矿不外乎仅有两种选择，要么挖，要么不挖，对吧？” “当然，当然”大臣们回答倒。 国王继续说道：“如果我挖取第9座金矿的话那么我现在就能获得8888个金子，而我将用去1500个人，那么我还剩下8500个人。我亲爱的左部下，如果你告诉我当我把所有剩下的8500个人和所有剩下的其它金矿都交给你去开采你最多能给我挖出多少金子的话，那么我不就知道了在第9个金矿一定开采的情况下所能得到的最大金币数吗？”国王的左部下听后回答道：“国王陛下，您的意思是如果我能用8500个人在其它金矿最多开采出x个金币的话，那您一共就能够获得 x + 8888个金子，对吗？” “是啊，是啊……如果第9座金矿一定开采的话……”大臣们点头说到。 国王笑着继续对着他的右部下说到：“亲爱的右部下，也许我并不打算开采这第9座金矿，那么我依然拥有10000个人，如果我把这10000个人和剩下的金矿都给你的话，你最多能给我挖出多少个金子呢？” 国王的右部下聪明地说道：“尊敬的国王陛下，我明白您的意思了，如果我回答最多能购开采出y个金币的话，那您就可以在y和x+8888之间选择一个较大者，而这个较大者就是最终我们能获得的最大金币数，您看我这样理解对吗？” 国王笑得更灿烂了，问他的左部下：“那么亲爱的左部下，我给你8500个人和其余金矿的话你能告诉我最多能挖出多少金子吗？” “请您放心，这个问题难不倒我”。左部下向国王打包票说到。 国王高兴地继续问他的右部下：“那右部下你呢，如果我给你10000个人和其余金矿的话你能告诉我最多能挖出多少金子吗？” “当然能了！交给我吧！”右部下同左部下一样自信地回答道。 “那就拜托给你们两位了，现在我要回到我那舒适的王宫里去享受了，我期待着你们的答复。”国王说完就开始动身回去等消息了，他是多么地相信他的两个大臣能够给他一个准确的答复，因为国王其实知道他的两位大臣要比他聪明得多。 故事发展到这里，你是否在想国王的这两个大臣又是如何找到让国王满意的答案的呢？他们为什么能够如此自信呢？事实上他们的确比国王要聪明一些，因为他们从国王的身上学到了一点，就是这一点让他们充满了自信。 国王走后，国王的左、右部下来到了第8座金矿，早已在那里等待他们的金矿勘测兵向两位大臣报道：“聪明的两位大臣，您们好，第8座金矿需要1000个人才能开采，可以获得7000个金子”。因为国王仅给他的左部下8500个人，所以国王的左部下叫来了两个人，对着其中一个人问到：“如果我给你7500个人和除了第8、第9的其它所有金矿的话，你能告诉我你最多能挖出多少金子吗？” 然后国王的左部下继续问另一个人：“如果我给你8500个人和除了第8、第9的其它所有金矿的话，你能告诉我你最多能挖出多少金子吗？” 国王的左部下在心里想着：“如果他们俩都能回答我的问题的话，那国王交给我的问题不就解决了吗？哈哈哈！” 因为国王给了他的右部下10000个人，所以国王的右部下同样也叫来了两个人，对着其中一个人问：“如果我给你9000个人和除了第8、第9的其它所有金矿的话，你能告诉我你最多能挖出多少金子吗？” 然后国王的右部下继续问他叫来的另一个人：“如果我给你10000个人和除了第8、第9的其它所有金矿的话，你能告诉我你最多能挖出多少金子吗？” 此时，国王的右部下同左部下一样，他们都在为自己如此聪明而感到满足。 当然，这四个被叫来的人同样自信地回答没有问题，因为他们同样地从这两个大臣身上学到了相同的一点，而两位自认为自己一样很聪明的大臣得意地笑着回到了他们的府邸，等着别人回答他们提出来的问题，现在你知道了这两个大臣是如何解决国王交待给他们的问题了吗？ 那么你认为被大臣叫去的那四个人又是怎么完成大臣交给他们的问题的呢？答案当然是他们找到了另外八个人！ 没用多少功夫，这个问题已经在全国传开了，更多人的人找到了更更多的人来解决这个问题，而有些人却不需要去另外找两个人帮他，哪些人不需要别人的帮助就可以回答他们的问题呢？ 很明显，当被问到给你z个人和仅有第0座金矿时最多能挖出多少金子时，就不需要别人的帮助，因为你知道，如果z大于等于挖取第0座金矿所需要的人数的话，那么挖出来的最多金子数就是第0座金矿能够挖出来的金子数，如果这z个人不够开采第0座金矿，那么能挖出来的最多金子数就是0，因为这唯一的金矿不够人力去开采。让我们为这些不需要别人的帮助就可以准确地得出答案的人们鼓掌吧，这就是传说中的底层劳动人民！ 故事讲到这里先暂停一下，我们现在重新来分析一下这个故事，让我们对动态规划有个理性认识。 子问题： 国王需要根据两个大臣的答案以及第9座金矿的信息才能判断出最多能够开采出多少金子。为了解决自己面临的问题，他需要给别人制造另外两个问题，这两个问题就是子问题。 最优子结构： 国王相信，只要他的两个大臣能够回答出正确的答案（对于考虑能够开采出的金子数，最多的也就是最优的同时也就是正确的），再加上他的聪明的判断就一定能得到最终的正确答案。我们把这种子问题最优时母问题通过优化选择后一定最优的情况叫做“最优子结构”。 子问题重叠： 实际上国王也好，大臣也好，所有人面对的都是同样的问题，即给你一定数量的人，给你一定数量的金矿，让你求出能够开采出来的最多金子数。我们把这种母问题与子问题本质上是同一个问题的情况称为“子问题重叠”。然而问题中出现的不同点往往就是被子问题之间传递的参数，比如这里的人数和金矿数。 边界： 想想如果不存在前面我们提到的那些底层劳动者的话这个问题能解决吗？永远都不可能！我们把这种子问题在一定时候就不再需要提出子子问题的情况叫做边界，没有边界就会出现死循环。 子问题独立： 要知道，当国王的两个大臣在思考他们自己的问题时他们是不会关心对方是如何计算怎样开采金矿的，因为他们知道，国王只会选择两个人中的一个作为最后方案，另一个人的方案并不会得到实施，因此一个人的决定对另一个人的决定是没有影响的。我们把这种一个母问题在对子问题选择时，当前被选择的子问题两两互不影响的情况叫做“子问题独立”。 这就是动态规划，具有“最优子结构”、“子问题重叠”、“边界”和“子问题独立”，当你发现你正在思考的问题具备这四个性质的话，那么恭喜你，你基本上已经找到了动态规划的方法。 有了上面的这几点，我们就可以写出动态规划的转移方程式，现在我们来写出对应这个问题的方程式，如果用gold[mineNum]表示第mineNum个金矿能够挖出的金子数，用peopleNeeded[mineNum]表示挖第mineNum个金矿需要的人数，用函数f(people,mineNum)表示当有people个人和编号为0、1、2、3、……、mineNum的金矿时能够得到的最大金子数的话，f(people,mineNum)等于什么呢？或者说f(people,mineNum)的转移方程是怎样的呢？ 答案是： 当mineNum = 0且people &gt;= peopleNeeded[mineNum]时 f(people,mineNum) = gold[mineNum] 当mineNum = 0且people &lt; peopleNeeded[mineNum]时 f(people,mineNum) = 0 当mineNum != 0时 f(people,mineNum) = f(people-peopleNeeded[mineNum], mineNum-1) + gold[mineNum]与f(people, mineNum-1)中的较大者，前两个式子对应动态规划的“边界”，后一个式子对应动态规划的“最优子结构”请读者弄明白后再继续往下看。 —-第二节—-动态规划的优点——– 现在我假设读者你已经搞清楚了为什么动态规划是正确的方法，但是我们为什么需要使用动态规划呢？请先继续欣赏这个故事： 国王得知他的两个手下使用了和他相同的方法去解决交代给他们的问题后，不但没有认为他的两个大臣在偷懒，反而很高兴，因为他知道，他的大臣必然会找更多的人一起解决这个问题，而更多的人会找更更多的人，这样他这个聪明的方法就会在不经意间流传开来，而全国人民都会知道这个聪明的方法是他们伟大的国王想出来的，你说国王能不高兴吗？ 但是国王也有一些担忧，因为他实在不知道这个“工程”要动用到多少人来完成，如果帮助他解决这个问题的人太多的话那么就太劳民伤财了。“会不会影响到今年的收成呢？”国王在心里想着这个问题，于是他请来了整个国家里唯一的两个数学天才，一个叫做小天，另一个叫做小才。 国王问小天：“小天啊，我发觉这个问题有点严重，我知道其实这可以简单的看成一个组合问题，也就是从十个金矿中选取若干个金矿进行开采，看看哪种组合得到的金子最多，也许用组合方法会更好一些。你能告诉我一共有多少种组合情况吗？” “国王陛下，如果用组合方法的话一共要考虑2的10次方种情况，也就是1024种情况。”小天思考了一会回答到。 “嗯……，如果每一种情况我交给一个人去计算能得到的金子数的话，那我也要1024个人，其实还是挺多的。”国王好像再次感觉到了自己的方法是正确的。 国王心理期待着小才能够给它一个更好的答案，问到：“小才啊，那么你能告诉我用我的那个方法总共需要多少人吗？其实，我也计算过，好像需要的人数是1+2+4+8+16+32+64+……，毕竟每一个人的确都需要找另外两个人来帮助他们……” 不辜负国王的期待，小才微笑着说到：“亲爱的国王陛下，其实我们并不需要那么多人，因为有很多问题其实是相同的，而我们只需要为每一个不同的问题使用一个人力便可。” 国王高兴的问到：“此话如何讲？” “打个比方，如果有一个人需要知道1000个人和3个金矿可以开采出多少金子，同时另一个人也需要知道1000个人和3个金矿可以开采出多少金子的话，那么他们可以去询问相同的一个人，而不用各自找不同的人浪费人力了。” 国王思考着说到：“嗯，很有道理，如果问题是一样的话那么就不需要去询问两个不同的人了，也就是说一个不同的问题仅需要一个人力，那么一共有多少个不同的问题呢？” “因为每个问题的人数可以从0取到10000，而金矿数可以从0取到10，所以最多大约有10000 * 10 等于100000个不同的问题。” 小才一边算着一边回答。 “什么？十万个问题？十万个人力？”国王有点失望。 “请国王放心，事实上我们需要的人力远远小于这个数的，因为不是每一个问题都会遇到，也许我们仅需要一、两百个人力就可以解决这个问题了，这主要和各个金矿所需要的人数有关。” 小才立刻回答到。 故事的最后，自然是国王再一次向他的臣民们证明了他是这个国家里最聪明的人，现在我们通过故事的第二部分来考虑动态规划的另外两个思考点。 思考动态规划的第五点—-做备忘录： 正如上面所说的一样，当我们遇到相同的问题时，我们可以问同一个人。讲的通俗一点就是，我们可以把问题的解放在一个变量中，如果再次遇到这个问题就直接从变量中获得答案，因此每一个问题仅会计算一遍，如果不做备忘的话，动态规划就没有任何优势可言了。 思考动态规划的第六点—-时间分析： 正如上面所说，如果我们用穷举的方法，至少需要2^n个常数时间，因为总共有2^n种情况需要考虑，如果在背包问题中，包的容量为1000，物品数为100，那么需要考虑2^100种情况,这个数大约为10的30次方。 而如果用动态规划，最多大概只有1000*100 = 100000个不同的问题，这和10的30次方比起来优势是很明显的。而实际情况并不会出现那么多不同的问题，比如在金矿模型中，如果所有的金矿所需人口都是1000个人，那么问题总数大约只有100个。 非正式地，我们可以很容易得到动态规划所需时间，如果共有questionCount个相同的子问题，而每一个问题需要面对chooseCount种选择时，我们所需时间就为questionCount chooseCount个常数。在金矿模型中，子问题最多有大概people n 个(其中people是用于开采金矿的总人数，n是金矿的总数)，因此questionCount = people n，而就像国王需要考虑是采用左部下的结果还是采用右部下的结果一样，每个问题面对两个选择，因此chooseCount = 2,所以程序运行时间为** T = O(questionCount chooseCount) =O(people n)*，别忘了实际上需要的时间小于这个值，根据所遇到的具体情况有所不同。 这就是动态规划的魔力，它减少了大量的计算，因此我们需要动态规划！ —-第三节—-动态规划的思考角度———- 那么什么是动态规划呢？我个人觉得，如果一个解决问题的方法满足上面六个思考点中的前四个，那么这个方法就属于动态规划。而在思考动态规划方法时，后两点同样也是需要考虑的。 面对问题要寻找动态规划的方法，首先要清楚一点，动态规划不是算法，它是一种方法，它是在一件事情发生的过程中寻找最优值的方法，因此，我们需要对这件事情所发生的过程进行考虑。而通常我们从过程的最后一步开始考虑，而不是先考虑过程的开始。 打个比方，上面的挖金矿问题，我们可以认为整个开采过程是从西至东进行开采的（也就是从第0座开始），那么总有面对最后一座金矿的时候（第9座），对这座金矿不外乎两个选择，开采与不开采，在最后一步确定时再去确定倒数第二步，直到考虑第0座金矿（过程的开始）。 而过程的开始，也就是考虑的最后一步，就是边界。 因此在遇到一个问题想用动态规划的方法去解决时，不妨先思考一下这个过程是怎样的，然后考虑过程的最后一步是如何选择的，通常我们需要自己去构造一个过程，比如后面的练习。 —-第四节—-总结——- 那么遇到问题如何用动态规划去解决呢？根据上面的分析我们可以按照下面的步骤去考虑： 1、构造问题所对应的过程。 2、思考过程的最后一个步骤，看看有哪些选择情况。 3、找到最后一步的子问题，确保符合“子问题重叠”，把子问题中不相同的地方设置为参数。 4、使得子问题符合“最优子结构”。 5、找到边界，考虑边界的各种处理方式。 6、确保满足“子问题独立”，一般而言，如果我们是在多个子问题中选择一个作为实施方案，而不会同时实施多个方案，那么子问题就是独立的。 7、考虑如何做备忘录。 8、分析所需时间是否满足要求。 9、写出转移方程式。 —-第五节—-练习——- 题目一：买书 有一书店引进了一套书，共有3卷，每卷书定价是60元，书店为了搞促销，推出一个活动，活动如下： 如果单独购买其中一卷，那么可以打9.5折。 如果同时购买两卷不同的，那么可以打9折。 如果同时购买三卷不同的，那么可以打8.5折。 如果小明希望购买第1卷x本，第2卷y本，第3卷z本，那么至少需要多少钱呢？（x、y、z为三个已知整数）。 当然，这道题完全可以不用动态规划来解，但是现在我们是要学习动态规划，因此请想想如何用动态规划来做？ 答案： 1、过程为一次一次的购买，每一次购买也许只买一本（这有三种方案），或者买两本（这也有三种方案），或者三本一起买（这有一种方案），最后直到买完所有需要的书。 2、最后一步我必然会在7种购买方案中选择一种，因此我要在7种购买方案中选择一个最佳情况。 3、子问题是，我选择了某个方案后，如何使得购买剩余的书能用最少的钱？并且这个选择不会使得剩余的书为负数。母问题和子问题都是给定三卷书的购买量，求最少需要用的钱，所以有“子问题重叠”，问题中三个购买量设置为参数，分别为i、j、k。 4、的确符合。 5、边界是一次购买就可以买完所有的书，处理方式请读者自己考虑。 6、每次选择最多有7种方案，并且不会同时实施其中多种，因此方案的选择互不影响，所以有“子问题独立”。 7、我可以用minMoney[i][j][k]来保存购买第1卷i本，第2卷j本，第3卷k本时所需的最少金钱。 8、共有x y z 个问题，每个问题面对7种选择，时间为：O( x y z 7) = O( x y * z )。 9、用函数MinMoney(i,j,k)来表示购买第1卷i本，第2卷j本，第3卷k本时所需的最少金钱，那么有： MinMoney(i,j,k)=min(s1,s2,s3,s4,s5,s6,s7),其中s1,s2,s3,s4,s5,s6,s7分别为对应的7种方案使用的最少金钱： s1 = 60 * 0.95 + MinMoney(i-1,j,k) s2 = 60 * 0.95 + MinMoney(i,j-1,k) s3 = 60 * 0.95 + MinMoney(i,j,k-1) s4 = (60 + 60) * 0.9 + MinMoney(i-1,j-1,k) s5 = (60 + 60) * 0.9 + MinMoney(i-1,j,k-1) s6 = (60 + 60) * 0.9 + MinMoney(i-1,j,k-1) s7 = (60 + 60 + 60) * 0.85 + MinMoney(i-1,j-1,k-1) 注：以上文章来自网络，原作者已不可考量，如有侵权请及时告知，２４小时内删除！","categories":[{"name":"技术","slug":"技术","permalink":"http://wxy-cs.com/categories/技术/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://wxy-cs.com/tags/算法/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://wxy-cs.com/categories/技术/"}]},{"title":"贪心算法","slug":"贪心算法","date":"2016-10-12T11:13:44.000Z","updated":"2016-10-13T10:00:17.344Z","comments":true,"path":"2016/10/12/贪心算法/","link":"","permalink":"http://wxy-cs.com/2016/10/12/贪心算法/","excerpt":"","text":"贪心算法是指在当前状态下选取最优的情况，即局部最优解，贪心算法不能保证对所有问题有整体最优解选择贪心算法必须具备无后效性(“过去与未来无关”) 基本思路 1.建立数学模型来描述问题 ⒉.把求解的问题分成若干个子问题。 ⒊.对每一子问题求解，得到子问题的局部最优解。 ⒋.把子问题的解局部最优解合成原来解问题的一个解。 区别(贪心算法与动态规划算法) 贪心算法是自顶向下，动态规划是自底向上。 贪心算法所做每一步决策是不可改变的，因为每一步的最优解都是由上一步最优解推导出来的。而且贪心算法不保留上一步之前的最优解。(活动安排问题，每一个活动与上一个安排的活动的结束时间相关)动态规划算法，全局最优解一定包含局部最优解，但不一定包含上一步的最优解，所以动态规划需要保存以前的所有最优解。(金矿模型，保存两个最优解) 原理 贪心选择性质 进行选择时，直接选出当前问题的最优解，而不关心子问题的最优解。 最优子结构当前问题的最优解一定包含子问题的最优解。 应用实例 不能用于０-1背包问题(不是整体最优解),但可以用于分数背包问题 赫夫曼编码（编码树、前缀码）","categories":[{"name":"技术","slug":"技术","permalink":"http://wxy-cs.com/categories/技术/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://wxy-cs.com/tags/算法/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://wxy-cs.com/categories/技术/"}]},{"title":"动态规划-01背包问题","slug":"动态规划-01背包问题","date":"2016-10-11T06:30:56.000Z","updated":"2016-10-12T11:01:11.289Z","comments":true,"path":"2016/10/11/动态规划-01背包问题/","link":"","permalink":"http://wxy-cs.com/2016/10/11/动态规划-01背包问题/","excerpt":"","text":"01背包问题是动态规划里的经典问题。动态规划的核心是找到状态和状态转移方程。 01背包问题的状态是 f[i,j] ：在前i件物品中选取若干件物品放在容量为j的背包里，可以获得的最大价值. 01背包问题的状态转移方程为 f[i,j]=max{f[i-1,j-wi]+pi,f[i-1,j]}(j&gt;=wi) 例子有编号分别为a,b,c,d,e的五件物品，它们的重量分别是2,2,6,5,4，它们的价值分别是6,3,5,4,6，现在给你个承重为10的背包，如何让背包里装入的物品具有最大的价值总和？注:e2代表只有物品e时，背包容量为2时，所能获得的最大价值，b2代表只有b c d e物品时，背包容量为2，所能获得的最大价值。 a8=15是如何来的？按照状态转换方程f[i,j]=max{f[i-1,j-wi]+pi,f[i-1,j]}得：f[i-1,j-wi]为单元格b6：只有b c d e几件物品，背包容量为6时，所能获取的最大价值f[i-1,j]为单元格b8：只有b c d e物品，背包容量为8时，所能获得的最大价值由表格得：f[i-1,j-wi]+wi=9+6=15 f[i-1,j]=9 所以a8=15 对于动态规划问题相关知识点: 重叠子问题 例如Fibonacci数列，如果计算第100项，依旧需要计算第99项和第98项时，这就称作重叠子问题 无后效性、最优子结构 如果状态转移方程的等式右边不会用到下标大于左边的i或k时，这就是无后效性(某阶段的状态一旦确定，此后过程演变不再受之前的各种状态和决策影响，即：“未来与过去无关”当前的状态是此前历史的一个完整总结，此前的历史只能通过当前的状态去影响过程未来的演变),符合这种定义的状态定义就称为最优子结构 注：以上图片、文字均有部分参考自网络，如有侵权请及时告知，将在24小时内删除！","categories":[{"name":"技术","slug":"技术","permalink":"http://wxy-cs.com/categories/技术/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://wxy-cs.com/tags/算法/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://wxy-cs.com/categories/技术/"}]},{"title":"动态规划：从新手到专家","slug":"动态规划：从新手到专家","date":"2016-10-10T10:14:24.000Z","updated":"2016-10-10T14:06:32.828Z","comments":true,"path":"2016/10/10/动态规划：从新手到专家/","link":"","permalink":"http://wxy-cs.com/2016/10/10/动态规划：从新手到专家/","excerpt":"","text":"March 26, 2013作者：Hawstein出处：http://hawstein.com/posts/dp-novice-to-advanced.html声明：本文采用以下协议进行授权： 自由转载-非商用-非衍生-保持署名|Creative Commons BY-NC-ND 3.0 ，转载请注明作者及出处。 前言本文翻译自TopCoder上的一篇文章：Dynamic Programming: From novice to advanced ，并非严格逐字逐句翻译，其中加入了自己的一些理解。水平有限，还望指摘。 简介（入门）什么是动态规划，我们要如何描述它?动态规划算法通常基于一个递推公式及一个或多个初始状态。 当前子问题的解将由上一次子问题的解推出。使用动态规划来解题只需要多项式时间复杂度， 因此它比回溯法、暴力法等要快许多。 现在让我们通过一个例子来了解一下DP的基本原理。 首先，我们要找到某个状态的最优解，然后在它的帮助下，找到下一个状态的最优解。 “状态”代表什么及如何找到它?“状态”用来描述该问题的子问题的解。原文中有两段作者阐述得不太清楚，跳过直接上例子。 如果我们有面值为1元、3元和5元的硬币若干枚，如何用最少的硬币凑够11元？ (表面上这道题可以用贪心算法，但贪心算法无法保证可以求出解，比如1元换成2元的时候) 首先我们思考一个问题，如何用最少的硬币凑够i元(i&lt;11)？为什么要这么问呢？ 两个原因：1.当我们遇到一个大问题时，总是习惯把问题的规模变小，这样便于分析讨论。 2.这个规模变小后的问题和原来的问题是同质的，除了规模变小，其它的都是一样的， 本质上它还是同一个问题(规模变小后的问题其实是原问题的子问题)。 好了，让我们从最小的i开始吧。当i=0，即我们需要多少个硬币来凑够0元。 由于1，3，5都大于0，即没有比0小的币值，因此凑够0元我们最少需要0个硬币。 (这个分析很傻是不是？别着急，这个思路有利于我们理清动态规划究竟在做些什么。) 这时候我们发现用一个标记来表示这句“凑够0元我们最少需要0个硬币。”会比较方便， 如果一直用纯文字来表述，不出一会儿你就会觉得很绕了。那么， 我们用d(i)=j来表示凑够i元最少需要j个硬币。于是我们已经得到了d(0)=0， 表示凑够0元最小需要0个硬币。当i=1时，只有面值为1元的硬币可用， 因此我们拿起一个面值为1的硬币，接下来只需要凑够0元即可，而这个是已经知道答案的， 即d(0)=0。所以，d(1)=d(1-1)+1=d(0)+1=0+1=1。当i=2时， 仍然只有面值为1的硬币可用，于是我拿起一个面值为1的硬币， 接下来我只需要再凑够2-1=1元即可(记得要用最小的硬币数量)，而这个答案也已经知道了。 所以d(2)=d(2-1)+1=d(1)+1=1+1=2。一直到这里，你都可能会觉得，好无聊， 感觉像做小学生的题目似的。因为我们一直都只能操作面值为1的硬币！耐心点， 让我们看看i=3时的情况。当i=3时，我们能用的硬币就有两种了：1元的和3元的( 5元的仍然没用，因为你需要凑的数目是3元！5元太多了亲)。 既然能用的硬币有两种，我就有两种方案。如果我拿了一个1元的硬币，我的目标就变为了： 凑够3-1=2元需要的最少硬币数量。即d(3)=d(3-1)+1=d(2)+1=2+1=3。 这个方案说的是，我拿3个1元的硬币；第二种方案是我拿起一个3元的硬币， 我的目标就变成：凑够3-3=0元需要的最少硬币数量。即d(3)=d(3-3)+1=d(0)+1=0+1=1. 这个方案说的是，我拿1个3元的硬币。好了，这两种方案哪种更优呢？ 记得我们可是要用最少的硬币数量来凑够3元的。所以， 选择d(3)=1，怎么来的呢？具体是这样得到的：d(3)=min{d(3-1)+1, d(3-3)+1}。 OK，码了这么多字讲具体的东西，让我们来点抽象的。从以上的文字中， 我们要抽出动态规划里非常重要的两个概念：状态和状态转移方程。 上文中d(i)表示凑够i元需要的最少硬币数量，我们将它定义为该问题的”状态”， 这个状态是怎么找出来的呢？我在另一篇文章 动态规划之背包问题(一)中写过： 根据子问题定义状态。你找到子问题，状态也就浮出水面了。 最终我们要求解的问题，可以用这个状态来表示：d(11)，即凑够11元最少需要多少个硬币。 那状态转移方程是什么呢？既然我们用d(i)表示状态，那么状态转移方程自然包含d(i)， 上文中包含状态d(i)的方程是：d(3)=min{d(3-1)+1, d(3-3)+1}。没错， 它就是状态转移方程，描述状态之间是如何转移的。当然，我们要对它抽象一下， d(i)=min{ d(i-vj)+1 }，其中i-vj &gt;=0，vj表示第j个硬币的面值; 有了状态和状态转移方程，这个问题基本上也就解决了。当然了，Talk is cheap,show me the code! 伪代码如下：下图是当i从0到11时的解：从上图可以得出，要凑够11元至少需要3枚硬币。 此外，通过追踪我们是如何从前一个状态值得到当前状态值的， 可以找到每一次我们用的是什么面值的硬币。比如，从上面的图我们可以看出， 最终结果d(11)=d(10)+1(面值为1)，而d(10)=d(5)+1(面值为5)，最后d(5)=d(0)+1 (面值为5)。所以我们凑够11元最少需要的3枚硬币是：1元、5元、5元。 注意：原文中这里本来还有一段的，但我反反复复读了几遍， 大概的意思我已经在上文从i=0到i=3的分析中有所体现了。作者本来想讲的通俗一些， 结果没写好，反而更不好懂，所以这段不翻译了。 初级上面讨论了一个非常简单的例子。现在让我们来看看对于更复杂的问题， 如何找到状态之间的转移方式(即找到状态转移方程)。 为此我们要引入一个新词叫递推关系来将状态联系起来(说的还是状态转移方程) OK，上例子，看看它是如何工作的。 一个序列有N个数：A[1],A[2],…,A[N]，求出最长非降子序列的长度。 (讲DP基本都会讲到的一个问题LIS：longest increasing subsequence) 正如上面我们讲的，面对这样一个问题，我们首先要定义一个“状态”来代表它的子问题， 并且找到它的解。注意，大部分情况下，某个状态只与它前面出现的状态有关， 而独立于后面的状态。 让我们沿用“入门”一节里那道简单题的思路来一步步找到“状态”和“状态转移方程”。 假如我们考虑求A[1],A[2],…,A[i]的最长非降子序列的长度，其中i&lt;N， 那么上面的问题变成了原问题的一个子问题(问题规模变小了，你可以让i=1,2,3等来分析) 然后我们定义d(i)，表示前i个数中以A[i]结尾的最长非降子序列的长度。OK， 对照“入门”中的简单题，你应该可以估计到这个d(i)就是我们要找的状态。 如果我们把d(1)到d(N)都计算出来，那么最终我们要找的答案就是这里面最大的那个。 状态找到了，下一步找出状态转移方程。 为了方便理解我们是如何找到状态转移方程的，我先把下面的例子提到前面来讲。 如果我们要求的这N个数的序列是： 5，3，4，8，6，7 根据上面找到的状态，我们可以得到：（下文的最长非降子序列都用LIS表示） 前1个数的LIS长度d(1)=1(序列：5)前2个数的LIS长度d(2)=1(序列：3；3前面没有比3小的)前3个数的LIS长度d(3)=2(序列：3，4；4前面有个比它小的3，所以d(3)=d(2)+1)前4个数的LIS长度d(4)=3(序列：3，4，8；8前面比它小的有3个数，所以 d(4)=max{d(1),d(2),d(3)}+1=3)OK，分析到这，我觉得状态转移方程已经很明显了，如果我们已经求出了d(1)到d(i-1)， 那么d(i)可以用下面的状态转移方程得到： d(i) = max{1, d(j)+1},其中j&lt;i,A[j]&lt;=A[i] 用大白话解释就是，想要求d(i)，就把i前面的各个子序列中， 最后一个数不大于A[i]的序列长度加1，然后取出最大的长度即为d(i)。 当然了，有可能i前面的各个子序列中最后一个数都大于A[i]，那么d(i)=1， 即它自身成为一个长度为1的子序列。 分析完了，上图：(第二列表示前i个数中LIS的长度， 第三列表示，LIS中到达当前这个数的上一个数的下标，根据这个可以求出LIS序列) 中级接下来，让我们来看看如何解决二维的DP问题。 平面上有N＊M个格子，每个格子中放着一定数量的苹果。你从左上角的格子开始， 每一步只能向下走或是向右走，每次走到一个格子上就把格子里的苹果收集起来， 这样下去，你最多能收集到多少个苹果。 解这个问题与解其它的DP问题几乎没有什么两样。第一步找到问题的“状态”， 第二步找到“状态转移方程”，然后基本上问题就解决了。 首先，我们要找到这个问题中的“状态”是什么？我们必须注意到的一点是， 到达一个格子的方式最多只有两种：从左边来的(除了第一列)和从上边来的(除了第一行)。 因此为了求出到达当前格子后最多能收集到多少个苹果， 我们就要先去考察那些能到达当前这个格子的格子，到达它们最多能收集到多少个苹果。 (是不是有点绕，但这句话的本质其实是DP的关键：欲求问题的解，先要去求子问题的解) 经过上面的分析，很容易可以得出问题的状态和状态转移方程。 状态S[i][j]表示我们走到(i, j)这个格子时，最多能收集到多少个苹果。那么， 状态转移方程如下： S[i][j]=A[i][j] + max(S[i-1][j], if i&gt;0 ; S[i][j-1], if j&gt;0)其中i代表行，j代表列，下标均从0开始；A[i][j]代表格子(i, j)处的苹果数量。 S[i][j]有两种计算方式：1.对于每一行，从左向右计算，然后从上到下逐行处理；2. 对于每一列，从上到下计算，然后从左向右逐列处理。 这样做的目的是为了在计算S[i][j]时，S[i-1][j]和S[i][j-1]都已经计算出来了。 伪代码如下： 中高级这一节要讨论的是带有额外条件的DP问题。 以下的这个问题是个很好的例子。 无向图G有N个结点，它的边上带有正的权重值。 你从结点1开始走，并且一开始的时候你身上带有M元钱。如果你经过结点i， 那么你就要花掉S[i]元(可以把这想象为收过路费)。如果你没有足够的钱， 就不能从那个结点经过。在这样的限制条件下，找到从结点1到结点N的最短路径。 或者输出该路径不存在。如果存在多条最短路径，那么输出花钱数量最少的那条。 限制：1&lt;N&lt;=100 ; 0&lt;=M&lt;=100 ; 对于每个i，0&lt;=S[i]&lt;=100；正如我们所看到的， 如果没有额外的限制条件(在结点处要收费，费用不足还不给过)，那么， 这个问题就和经典的迪杰斯特拉问题一样了(找到两结点间的最短路径)。 在经典的迪杰斯特拉问题中， 我们使用一个一维数组来保存从开始结点到每个结点的最短路径的长度， 即M[i]表示从开始结点到结点i的最短路径的长度。然而在这个问题中， 我们还要保存我们身上剩余多少钱这个信息。因此，很自然的， 我们将一维数组扩展为二维数组。M[i][j]表示从开始结点到结点i的最短路径长度， 且剩余j元。通过这种方式，我们将这个问题规约到原始的路径寻找问题。 在每一步中，对于已经找到的最短路径，我们找到它所能到达的下一个未标记状态(i,j)， 将它标记为已访问(之后不再访问这个结点)，并且在能到达这个结点的各个最短路径中， 找到加上当前边权重值后最小值对应的路径，即为该结点的最短路径。 (写起来真是绕，建议画个图就会明了很多)。不断重复上面的步骤， 直到所有的结点都访问到为止(这里的访问并不是要求我们要经过它， 比如有个结点收费很高，你没有足够的钱去经过它，但你已经访问过它) 最后Min[N-1][j]中的最小值即是问题的答案(如果有多个最小值， 即有多条最短路径，那么选择j最大的那条路径，即，使你剩余钱数最多的最短路径)。 伪代码： 高级以下问题需要仔细的揣摩才能将其规约为可用DP解的问题。 问题：StarAdventure – SRM 208 Div 1: 给定一个M行N列的矩阵(M*N个格子)，每个格子中放着一定数量的苹果。 你从左上角的格子开始，只能向下或向右走，目的地是右下角的格子。 你每走过一个格子，就把格子上的苹果都收集起来。然后你从右下角走回左上角的格子， 每次只能向左或是向上走，同样的，走过一个格子就把里面的苹果都收集起来。 最后，你再一次从左上角走到右下角，每过一个格子同样要收集起里面的苹果 (如果格子里的苹果数为0，就不用收集)。求你最多能收集到多少苹果。 注意：当你经过一个格子时，你要一次性把格子里的苹果都拿走。 限制条件：1 &lt; N, M &lt;= 50；每个格子里的苹果数量是0到1000(包含0和1000)。 如果我们只需要从左上角的格子走到右下角的格子一次，并且收集最大数量的苹果， 那么问题就退化为“中级”一节里的那个问题。将这里的问题规约为“中级”里的简单题， 这样一来会比较好解。让我们来分析一下这个问题，要如何规约或是修改才能用上DP。 首先，对于第二次从右下角走到左上角得出的这条路径， 我们可以将它视为从左上角走到右下角得出的路径，没有任何的差别。 (即从B走到A的最优路径和从A走到B的最优路径是一样的)通过这种方式， 我们得到了三条从顶走到底的路径。对于这一点的理解可以稍微减小问题的难度。 于是，我们可以将这3条路径记为左，中，右路径。对于两条相交路径(如下图)：在不影响结果的情况下，我们可以将它们视为两条不相交的路径：这样一来，我们将得到左，中，右3条路径。此外，如果我们要得到最优解， 路径之间不能相交(除了左上角和右下角必然会相交的格子)。因此对于每一行y( 除了第一行和最后一行)，三条路径对应的x坐标要满足：x1[y] &lt; x2[y] &lt; x3[y]。 经过这一步的分析，问题的DP解法就进一步地清晰了。让我们考虑行y， 对于每一个x1[y-1]，x2[y-1]和x3[y-1]，我们已经找到了能收集到最多苹果数量的路径。 根据它们，我们能求出行y的最优解。现在我们要做的就是找到从一行移动到下一行的方式。 令Max[i][j][k]表示到第y-1行为止收集到苹果的最大数量， 其中3条路径分别止于第i,j,k列。对于下一行y，对每个Max[i][j][k] 都加上格子(y,i)，(y,j)和(y,k)内的苹果数量。因此，每一步我们都向下移动。 我们做了这一步移动之后，还要考虑到，一条路径是有可能向右移动的。 (对于每一个格子，我们有可能是从它上面向下移动到它， 也可能是从它左边向右移动到它)。为了保证3条路径互不相交， 我们首先要考虑左边的路径向右移动的情况，然后是中间，最后是右边的路径。 为了更好的理解，让我们来考虑左边的路径向右移动的情况，对于每一个可能的j,k对(j&lt;k)， 对每个i(i&lt;j)，考虑从位置(i-1,j,k)移动到位置(i,j,k)。处理完左边的路径， 再处理中间的路径，最后处理右边的路径。方法都差不多。 其它当阅读一个题目并且开始尝试解决它时，首先看一下它的限制。 如果要求在多项式时间内解决，那么该问题就很可能要用DP来解。遇到这种情况， 最重要的就是找到问题的“状态”和“状态转移方程”。(状态不是随便定义的， 一般定义完状态，你要找到当前状态是如何从前面的状态得到的， 即找到状态转移方程)如果看起来是个DP问题，但你却无法定义出状态， 那么试着将问题规约到一个已知的DP问题(正如“高级”一节中的例子一样)。","categories":[{"name":"技术","slug":"技术","permalink":"http://wxy-cs.com/categories/技术/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://wxy-cs.com/tags/算法/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://wxy-cs.com/categories/技术/"}]},{"title":"Dijkstra(迪杰斯特拉)算法","slug":"Dijkstra-迪杰斯特拉-算法","date":"2016-10-10T07:31:18.000Z","updated":"2016-11-16T05:09:52.964Z","comments":true,"path":"2016/10/10/Dijkstra-迪杰斯特拉-算法/","link":"","permalink":"http://wxy-cs.com/2016/10/10/Dijkstra-迪杰斯特拉-算法/","excerpt":"","text":"迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个节点到其它节点的最短路径。 迪杰斯特拉(Dijkstra)算法以起点为中心层层向外扩展（广度优先搜索思想）,直到扩展到终点为止。 原理 首先，引进一个辅助向量D，它的每个分量D表示当前所找到的从始点v到每个终点vi的最短路径的长度。如D[3]=2表示从始点v到终点3的路径相对最小长度为2。这里强调相对就是说在算法过程中D的值是在不断逼近最终结果但在过程中不一定就等于最短路径长度。它的初始状态为：若从v到vi有弧，则D为弧上的权值；否则置D为∞。显然，长度为 D[j]=Min{D | vi∈V} 的路径就是从v出发的长度最短的一条最短路径。此路径为(v,vj)。 那么，下一条长度次短的最短路径是哪一条呢？假设该次短路径的终点是vk，则可想而知，这条路径或者是(v,vk)，或者是(v,vj,vk)。它的长度或者是从v到vk的弧上的权值，或者是D[j]和从vj到vk的弧上的权值之和。 一般情况下，假设S为已求得最短路径的终点的集合，则可证明：下一条最短路径（设其终点为X）或者是弧(v,x)，或者是中间只经过S中的顶点而最后到达顶点X的路径。因此，下一条长度次短的最短路径的长度必是D[j]=Min{D | vi∈V-S} 其中，D或者是弧(v,vi)上的权值，或者是Dk和弧(vk,vi)上的权值之和。 基本思想 通过Dijkstra计算图G中的最短路径时，需要指定起点s(即从顶点s开始计算)。 此外，引进两个集合S和U。S的作用是记录已求出最短路径的顶点(以及相应的最短路径长度)，而U则是记录还未求出最短路径的顶点(以及该顶点到起点s的距离)。 初始时，S中只有起点s；U中是除s之外的顶点，并且U中顶点的路径是”起点s到该顶点的路径”。然后，从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 然后，再从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 … 重复该操作，直到遍历完所有顶点。 图解 动态图解 注：以上图片均来自网络，如有侵权，24小时内删除！","categories":[{"name":"技术","slug":"技术","permalink":"http://wxy-cs.com/categories/技术/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://wxy-cs.com/tags/算法/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://wxy-cs.com/categories/技术/"}]},{"title":"sql server存储过程和触发器","slug":"sql-server","date":"2016-05-18T11:04:40.000Z","updated":"2016-10-03T11:20:42.223Z","comments":true,"path":"2016/05/18/sql-server/","link":"","permalink":"http://wxy-cs.com/2016/05/18/sql-server/","excerpt":"","text":"存储过程存储过程Procedure是一组为了完成特定功能的SQL语句集合，经编译后存储在数据库中，用户通过指定存储过程的名称并给出参数来执行。 1.系统存储过程","categories":[{"name":"技术","slug":"技术","permalink":"http://wxy-cs.com/categories/技术/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://wxy-cs.com/tags/数据库/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://wxy-cs.com/categories/技术/"}]},{"title":"对多值依赖的理解","slug":"maltivalued-dependence","date":"2016-05-18T10:59:31.000Z","updated":"2016-10-03T11:19:13.051Z","comments":true,"path":"2016/05/18/maltivalued-dependence/","link":"","permalink":"http://wxy-cs.com/2016/05/18/maltivalued-dependence/","excerpt":"","text":"在关系数据库设计中的函数依赖理论中有一个多值依赖，对多值依赖的理解现做如下整理： 搜寻资料发现对多值依赖的讲解无非都用了两个关系模式的例子： 1.Teching（物理，老师，资料） 2.Storehouse（仓库管理员，仓库号，库存产品号） 首先说到多值依赖就会想到函数依赖，函数依赖规定了某些元组不能出现在关系中。如果A-&gt;B成立，我们就不能有两个元组在A上的值相同而在B上的值不同。而多值依赖却可以不排除这些元组的存在，所以函数依赖有时候又叫相等产生的依赖，而多值依赖又叫元组产生的依赖。 多值依赖从名字上看的理解是多个值依赖于同一个值 定义设R（U）是属性集U上的一个关系模式，X，Y，Z是U的子集，并且Z=U-X-Z。关系模式R上X-&gt;-&gt;Y成立，当且仅当对R（U）中的任意一个关系r,给定一对（X，Z）值，有一组Y的值与之对应，这组值仅仅取决于X的值，而与Z的值无关。 看定义很模糊，来看一个例子（来自《数据库系统概念》): ID dept_name street city 22222 Physics North Rye 22222 Physics Main Manchester 12121 Finance Lake Horseneck 是一个大学的关系模型，ID为教师的ID，一个教师有多个地址 我们按照定义来看一下，一个ID值有多个（street,city）与之对应。将ID看成X，将（street，city）看成Y，将dept_name看成Z，Z=U-X-Y,而且给定一组（X,Z）的值（我们选（2222，physics））有一组Y值与之对应（（North,Rye）,(Main,Manchester)）,所以可以说 ID-&gt;-&gt;street city 现在我们再来看一下开头说的两个例子: 例l： 学校中某一门课程由多个教员讲授，他们使用相同的一套参考书。每个教员可以讲授多门课程，每种参考书可以供多门课程使用。我们可以用一个非规范化的关系来表示教员T,课程C和参考书B之间的关系： 课程C 教员T 参考书B-————————————物理 李勇 普通物理学 王 军 光学原理 物理习题集-————————————数学 李 勇 数学分析 张 平 微分方程 高等代数 该关系模式存在全码(C,T,B),因此该关系模式属于BCNF范式 我们再来用多值依赖的定义来看一下这个关系模式：对于一个（物理，光学原理）有一组T值{李勇，王军}与之对应，但这组值仅仅取决于（物理），也就是说对于另一（物理，普通物理学），它对应的这组值仍然是{李勇，王军}，所以{李勇，王军}其实就是Z，物理是X，（普通物理学，光学原理，物理习题集）就是一组Y，C-&gt;-&gt;B成立！ 例2：有这样一个关系 &lt;仓库管理员，仓库号，库存产品号&gt; ，假设一个产品只能放到一个仓库中，但是一个仓库可以有若干管理员。 我们取一个（仓库管理员，仓库号），与之有一组库存产品号与之对应，而与仓库管理员无关，所以仓库号-&gt;-&gt;库存产品号,而这里面也存在仓库号-&gt;-&gt;仓库管理员,而与库存产品号无关。 推论 1.如果将对应一组Y值改为一个Y值，多值依赖就变成函数依赖了，所以可以说函数依赖是特殊的多值依赖。 2.若X-&gt;-&gt;Y，且Z为空集，则称X-&gt;-&gt;Y为平凡的多值依赖,否则称为非平凡的多值依赖。 存在的问题 1.冗余大 2.插入复杂 3.更新复杂 4.删除复杂 性质 1.对称性若X-&gt;-&gt;Y,则X-&gt;-&gt;Z，其中Z=U-X-Y 2.传递性若X-&gt;-&gt;Y, Y-&gt;-&gt;Z,则X-&gt;-&gt;Z 对称性: 参考文献:1.《数据库系统概念》， 杨冬青、李红燕、唐世渭，北京：机械工业出版社，20122.《数据库系统概论》，王珊、萨师煊，北京：高等教育出版社，2014","categories":[{"name":"技术","slug":"技术","permalink":"http://wxy-cs.com/categories/技术/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://wxy-cs.com/tags/数据库/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://wxy-cs.com/categories/技术/"}]}]}