{"meta":{"title":"学而知码，写而造轮","subtitle":null,"description":null,"author":"WXY","url":"http://wxy-cs.com"},"pages":[{"title":"About this web site","date":"2016-10-05T13:26:43.281Z","updated":"2016-10-05T13:26:43.277Z","comments":true,"path":"about/index.html","permalink":"http://wxy-cs.com/about/index.html","excerpt":"","text":"姓名: 王小猿 造不好轮子，撸不好代码的程序猿!"},{"title":"Categories","date":"2016-10-03T06:44:28.609Z","updated":"2016-09-19T14:18:54.000Z","comments":true,"path":"categories/index.html","permalink":"http://wxy-cs.com/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2016-10-03T06:44:28.609Z","updated":"2016-09-19T14:18:54.000Z","comments":true,"path":"tags/index.html","permalink":"http://wxy-cs.com/tags/index.html","excerpt":"","text":""},{"title":"weixin","date":"2016-10-03T10:45:17.000Z","updated":"2016-10-03T10:48:24.110Z","comments":true,"path":"weixin/index.html","permalink":"http://wxy-cs.com/weixin/index.html","excerpt":"","text":"请扫一扫，添加微信"}],"posts":[{"title":"动态规划-01背包问题","slug":"动态规划-01背包问题","date":"2016-10-11T06:30:56.000Z","updated":"2016-10-12T11:01:11.289Z","comments":true,"path":"2016/10/11/动态规划-01背包问题/","link":"","permalink":"http://wxy-cs.com/2016/10/11/动态规划-01背包问题/","excerpt":"","text":"01背包问题是动态规划里的经典问题。动态规划的核心是找到状态和状态转移方程。 01背包问题的状态是 f[i,j] ：在前i件物品中选取若干件物品放在容量为j的背包里，可以获得的最大价值. 01背包问题的状态转移方程为 f[i,j]=max{f[i-1,j-wi]+pi,f[i-1,j]}(j&gt;=wi) 例子有编号分别为a,b,c,d,e的五件物品，它们的重量分别是2,2,6,5,4，它们的价值分别是6,3,5,4,6，现在给你个承重为10的背包，如何让背包里装入的物品具有最大的价值总和？注:e2代表只有物品e时，背包容量为2时，所能获得的最大价值，b2代表只有b c d e物品时，背包容量为2，所能获得的最大价值。 a8=15是如何来的？按照状态转换方程f[i,j]=max{f[i-1,j-wi]+pi,f[i-1,j]}得：f[i-1,j-wi]为单元格b6：只有b c d e几件物品，背包容量为6时，所能获取的最大价值f[i-1,j]为单元格b8：只有b c d e物品，背包容量为8时，所能获得的最大价值由表格得：f[i-1,j-wi]+wi=9+6=15 f[i-1,j]=9 所以a8=15 对于动态规划问题相关知识点: 重叠子问题 例如Fibonacci数列，如果计算第100项，依旧需要计算第99项和第98项时，这就称作重叠子问题 无后效性、最优子结构 如果状态转移方程的等式右边不会用到下标大于左边的i或k时，这就是无后效性(某阶段的状态一旦确定，此后过程演变不再受之前的各种状态和决策影响，即：“未来与过去无关”当前的状态是此前历史的一个完整总结，此前的历史只能通过当前的状态去影响过程未来的演变),符合这种定义的状态定义就称为最优子结构 注：以上图片、文字均有部分参考自网络，如有侵权请及时告知，将在24小时内删除！","categories":[{"name":"技术","slug":"技术","permalink":"http://wxy-cs.com/categories/技术/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://wxy-cs.com/tags/算法/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://wxy-cs.com/categories/技术/"}]},{"title":"动态规划：从新手到专家","slug":"动态规划：从新手到专家","date":"2016-10-10T10:14:24.000Z","updated":"2016-10-10T14:06:32.828Z","comments":true,"path":"2016/10/10/动态规划：从新手到专家/","link":"","permalink":"http://wxy-cs.com/2016/10/10/动态规划：从新手到专家/","excerpt":"","text":"March 26, 2013作者：Hawstein出处：http://hawstein.com/posts/dp-novice-to-advanced.html声明：本文采用以下协议进行授权： 自由转载-非商用-非衍生-保持署名|Creative Commons BY-NC-ND 3.0 ，转载请注明作者及出处。 前言本文翻译自TopCoder上的一篇文章：Dynamic Programming: From novice to advanced ，并非严格逐字逐句翻译，其中加入了自己的一些理解。水平有限，还望指摘。 简介（入门）什么是动态规划，我们要如何描述它?动态规划算法通常基于一个递推公式及一个或多个初始状态。 当前子问题的解将由上一次子问题的解推出。使用动态规划来解题只需要多项式时间复杂度， 因此它比回溯法、暴力法等要快许多。 现在让我们通过一个例子来了解一下DP的基本原理。 首先，我们要找到某个状态的最优解，然后在它的帮助下，找到下一个状态的最优解。 “状态”代表什么及如何找到它?“状态”用来描述该问题的子问题的解。原文中有两段作者阐述得不太清楚，跳过直接上例子。 如果我们有面值为1元、3元和5元的硬币若干枚，如何用最少的硬币凑够11元？ (表面上这道题可以用贪心算法，但贪心算法无法保证可以求出解，比如1元换成2元的时候) 首先我们思考一个问题，如何用最少的硬币凑够i元(i&lt;11)？为什么要这么问呢？ 两个原因：1.当我们遇到一个大问题时，总是习惯把问题的规模变小，这样便于分析讨论。 2.这个规模变小后的问题和原来的问题是同质的，除了规模变小，其它的都是一样的， 本质上它还是同一个问题(规模变小后的问题其实是原问题的子问题)。 好了，让我们从最小的i开始吧。当i=0，即我们需要多少个硬币来凑够0元。 由于1，3，5都大于0，即没有比0小的币值，因此凑够0元我们最少需要0个硬币。 (这个分析很傻是不是？别着急，这个思路有利于我们理清动态规划究竟在做些什么。) 这时候我们发现用一个标记来表示这句“凑够0元我们最少需要0个硬币。”会比较方便， 如果一直用纯文字来表述，不出一会儿你就会觉得很绕了。那么， 我们用d(i)=j来表示凑够i元最少需要j个硬币。于是我们已经得到了d(0)=0， 表示凑够0元最小需要0个硬币。当i=1时，只有面值为1元的硬币可用， 因此我们拿起一个面值为1的硬币，接下来只需要凑够0元即可，而这个是已经知道答案的， 即d(0)=0。所以，d(1)=d(1-1)+1=d(0)+1=0+1=1。当i=2时， 仍然只有面值为1的硬币可用，于是我拿起一个面值为1的硬币， 接下来我只需要再凑够2-1=1元即可(记得要用最小的硬币数量)，而这个答案也已经知道了。 所以d(2)=d(2-1)+1=d(1)+1=1+1=2。一直到这里，你都可能会觉得，好无聊， 感觉像做小学生的题目似的。因为我们一直都只能操作面值为1的硬币！耐心点， 让我们看看i=3时的情况。当i=3时，我们能用的硬币就有两种了：1元的和3元的( 5元的仍然没用，因为你需要凑的数目是3元！5元太多了亲)。 既然能用的硬币有两种，我就有两种方案。如果我拿了一个1元的硬币，我的目标就变为了： 凑够3-1=2元需要的最少硬币数量。即d(3)=d(3-1)+1=d(2)+1=2+1=3。 这个方案说的是，我拿3个1元的硬币；第二种方案是我拿起一个3元的硬币， 我的目标就变成：凑够3-3=0元需要的最少硬币数量。即d(3)=d(3-3)+1=d(0)+1=0+1=1. 这个方案说的是，我拿1个3元的硬币。好了，这两种方案哪种更优呢？ 记得我们可是要用最少的硬币数量来凑够3元的。所以， 选择d(3)=1，怎么来的呢？具体是这样得到的：d(3)=min{d(3-1)+1, d(3-3)+1}。 OK，码了这么多字讲具体的东西，让我们来点抽象的。从以上的文字中， 我们要抽出动态规划里非常重要的两个概念：状态和状态转移方程。 上文中d(i)表示凑够i元需要的最少硬币数量，我们将它定义为该问题的”状态”， 这个状态是怎么找出来的呢？我在另一篇文章 动态规划之背包问题(一)中写过： 根据子问题定义状态。你找到子问题，状态也就浮出水面了。 最终我们要求解的问题，可以用这个状态来表示：d(11)，即凑够11元最少需要多少个硬币。 那状态转移方程是什么呢？既然我们用d(i)表示状态，那么状态转移方程自然包含d(i)， 上文中包含状态d(i)的方程是：d(3)=min{d(3-1)+1, d(3-3)+1}。没错， 它就是状态转移方程，描述状态之间是如何转移的。当然，我们要对它抽象一下， d(i)=min{ d(i-vj)+1 }，其中i-vj &gt;=0，vj表示第j个硬币的面值; 有了状态和状态转移方程，这个问题基本上也就解决了。当然了，Talk is cheap,show me the code! 伪代码如下：下图是当i从0到11时的解：从上图可以得出，要凑够11元至少需要3枚硬币。 此外，通过追踪我们是如何从前一个状态值得到当前状态值的， 可以找到每一次我们用的是什么面值的硬币。比如，从上面的图我们可以看出， 最终结果d(11)=d(10)+1(面值为1)，而d(10)=d(5)+1(面值为5)，最后d(5)=d(0)+1 (面值为5)。所以我们凑够11元最少需要的3枚硬币是：1元、5元、5元。 注意：原文中这里本来还有一段的，但我反反复复读了几遍， 大概的意思我已经在上文从i=0到i=3的分析中有所体现了。作者本来想讲的通俗一些， 结果没写好，反而更不好懂，所以这段不翻译了。 初级上面讨论了一个非常简单的例子。现在让我们来看看对于更复杂的问题， 如何找到状态之间的转移方式(即找到状态转移方程)。 为此我们要引入一个新词叫递推关系来将状态联系起来(说的还是状态转移方程) OK，上例子，看看它是如何工作的。 一个序列有N个数：A[1],A[2],…,A[N]，求出最长非降子序列的长度。 (讲DP基本都会讲到的一个问题LIS：longest increasing subsequence) 正如上面我们讲的，面对这样一个问题，我们首先要定义一个“状态”来代表它的子问题， 并且找到它的解。注意，大部分情况下，某个状态只与它前面出现的状态有关， 而独立于后面的状态。 让我们沿用“入门”一节里那道简单题的思路来一步步找到“状态”和“状态转移方程”。 假如我们考虑求A[1],A[2],…,A[i]的最长非降子序列的长度，其中i&lt;N， 那么上面的问题变成了原问题的一个子问题(问题规模变小了，你可以让i=1,2,3等来分析) 然后我们定义d(i)，表示前i个数中以A[i]结尾的最长非降子序列的长度。OK， 对照“入门”中的简单题，你应该可以估计到这个d(i)就是我们要找的状态。 如果我们把d(1)到d(N)都计算出来，那么最终我们要找的答案就是这里面最大的那个。 状态找到了，下一步找出状态转移方程。 为了方便理解我们是如何找到状态转移方程的，我先把下面的例子提到前面来讲。 如果我们要求的这N个数的序列是： 5，3，4，8，6，7 根据上面找到的状态，我们可以得到：（下文的最长非降子序列都用LIS表示） 前1个数的LIS长度d(1)=1(序列：5)前2个数的LIS长度d(2)=1(序列：3；3前面没有比3小的)前3个数的LIS长度d(3)=2(序列：3，4；4前面有个比它小的3，所以d(3)=d(2)+1)前4个数的LIS长度d(4)=3(序列：3，4，8；8前面比它小的有3个数，所以 d(4)=max{d(1),d(2),d(3)}+1=3)OK，分析到这，我觉得状态转移方程已经很明显了，如果我们已经求出了d(1)到d(i-1)， 那么d(i)可以用下面的状态转移方程得到： d(i) = max{1, d(j)+1},其中j&lt;i,A[j]&lt;=A[i] 用大白话解释就是，想要求d(i)，就把i前面的各个子序列中， 最后一个数不大于A[i]的序列长度加1，然后取出最大的长度即为d(i)。 当然了，有可能i前面的各个子序列中最后一个数都大于A[i]，那么d(i)=1， 即它自身成为一个长度为1的子序列。 分析完了，上图：(第二列表示前i个数中LIS的长度， 第三列表示，LIS中到达当前这个数的上一个数的下标，根据这个可以求出LIS序列) 中级接下来，让我们来看看如何解决二维的DP问题。 平面上有N＊M个格子，每个格子中放着一定数量的苹果。你从左上角的格子开始， 每一步只能向下走或是向右走，每次走到一个格子上就把格子里的苹果收集起来， 这样下去，你最多能收集到多少个苹果。 解这个问题与解其它的DP问题几乎没有什么两样。第一步找到问题的“状态”， 第二步找到“状态转移方程”，然后基本上问题就解决了。 首先，我们要找到这个问题中的“状态”是什么？我们必须注意到的一点是， 到达一个格子的方式最多只有两种：从左边来的(除了第一列)和从上边来的(除了第一行)。 因此为了求出到达当前格子后最多能收集到多少个苹果， 我们就要先去考察那些能到达当前这个格子的格子，到达它们最多能收集到多少个苹果。 (是不是有点绕，但这句话的本质其实是DP的关键：欲求问题的解，先要去求子问题的解) 经过上面的分析，很容易可以得出问题的状态和状态转移方程。 状态S[i][j]表示我们走到(i, j)这个格子时，最多能收集到多少个苹果。那么， 状态转移方程如下： S[i][j]=A[i][j] + max(S[i-1][j], if i&gt;0 ; S[i][j-1], if j&gt;0)其中i代表行，j代表列，下标均从0开始；A[i][j]代表格子(i, j)处的苹果数量。 S[i][j]有两种计算方式：1.对于每一行，从左向右计算，然后从上到下逐行处理；2. 对于每一列，从上到下计算，然后从左向右逐列处理。 这样做的目的是为了在计算S[i][j]时，S[i-1][j]和S[i][j-1]都已经计算出来了。 伪代码如下： 中高级这一节要讨论的是带有额外条件的DP问题。 以下的这个问题是个很好的例子。 无向图G有N个结点，它的边上带有正的权重值。 你从结点1开始走，并且一开始的时候你身上带有M元钱。如果你经过结点i， 那么你就要花掉S[i]元(可以把这想象为收过路费)。如果你没有足够的钱， 就不能从那个结点经过。在这样的限制条件下，找到从结点1到结点N的最短路径。 或者输出该路径不存在。如果存在多条最短路径，那么输出花钱数量最少的那条。 限制：1&lt;N&lt;=100 ; 0&lt;=M&lt;=100 ; 对于每个i，0&lt;=S[i]&lt;=100；正如我们所看到的， 如果没有额外的限制条件(在结点处要收费，费用不足还不给过)，那么， 这个问题就和经典的迪杰斯特拉问题一样了(找到两结点间的最短路径)。 在经典的迪杰斯特拉问题中， 我们使用一个一维数组来保存从开始结点到每个结点的最短路径的长度， 即M[i]表示从开始结点到结点i的最短路径的长度。然而在这个问题中， 我们还要保存我们身上剩余多少钱这个信息。因此，很自然的， 我们将一维数组扩展为二维数组。M[i][j]表示从开始结点到结点i的最短路径长度， 且剩余j元。通过这种方式，我们将这个问题规约到原始的路径寻找问题。 在每一步中，对于已经找到的最短路径，我们找到它所能到达的下一个未标记状态(i,j)， 将它标记为已访问(之后不再访问这个结点)，并且在能到达这个结点的各个最短路径中， 找到加上当前边权重值后最小值对应的路径，即为该结点的最短路径。 (写起来真是绕，建议画个图就会明了很多)。不断重复上面的步骤， 直到所有的结点都访问到为止(这里的访问并不是要求我们要经过它， 比如有个结点收费很高，你没有足够的钱去经过它，但你已经访问过它) 最后Min[N-1][j]中的最小值即是问题的答案(如果有多个最小值， 即有多条最短路径，那么选择j最大的那条路径，即，使你剩余钱数最多的最短路径)。 伪代码： 高级以下问题需要仔细的揣摩才能将其规约为可用DP解的问题。 问题：StarAdventure – SRM 208 Div 1: 给定一个M行N列的矩阵(M*N个格子)，每个格子中放着一定数量的苹果。 你从左上角的格子开始，只能向下或向右走，目的地是右下角的格子。 你每走过一个格子，就把格子上的苹果都收集起来。然后你从右下角走回左上角的格子， 每次只能向左或是向上走，同样的，走过一个格子就把里面的苹果都收集起来。 最后，你再一次从左上角走到右下角，每过一个格子同样要收集起里面的苹果 (如果格子里的苹果数为0，就不用收集)。求你最多能收集到多少苹果。 注意：当你经过一个格子时，你要一次性把格子里的苹果都拿走。 限制条件：1 &lt; N, M &lt;= 50；每个格子里的苹果数量是0到1000(包含0和1000)。 如果我们只需要从左上角的格子走到右下角的格子一次，并且收集最大数量的苹果， 那么问题就退化为“中级”一节里的那个问题。将这里的问题规约为“中级”里的简单题， 这样一来会比较好解。让我们来分析一下这个问题，要如何规约或是修改才能用上DP。 首先，对于第二次从右下角走到左上角得出的这条路径， 我们可以将它视为从左上角走到右下角得出的路径，没有任何的差别。 (即从B走到A的最优路径和从A走到B的最优路径是一样的)通过这种方式， 我们得到了三条从顶走到底的路径。对于这一点的理解可以稍微减小问题的难度。 于是，我们可以将这3条路径记为左，中，右路径。对于两条相交路径(如下图)：在不影响结果的情况下，我们可以将它们视为两条不相交的路径：这样一来，我们将得到左，中，右3条路径。此外，如果我们要得到最优解， 路径之间不能相交(除了左上角和右下角必然会相交的格子)。因此对于每一行y( 除了第一行和最后一行)，三条路径对应的x坐标要满足：x1[y] &lt; x2[y] &lt; x3[y]。 经过这一步的分析，问题的DP解法就进一步地清晰了。让我们考虑行y， 对于每一个x1[y-1]，x2[y-1]和x3[y-1]，我们已经找到了能收集到最多苹果数量的路径。 根据它们，我们能求出行y的最优解。现在我们要做的就是找到从一行移动到下一行的方式。 令Max[i][j][k]表示到第y-1行为止收集到苹果的最大数量， 其中3条路径分别止于第i,j,k列。对于下一行y，对每个Max[i][j][k] 都加上格子(y,i)，(y,j)和(y,k)内的苹果数量。因此，每一步我们都向下移动。 我们做了这一步移动之后，还要考虑到，一条路径是有可能向右移动的。 (对于每一个格子，我们有可能是从它上面向下移动到它， 也可能是从它左边向右移动到它)。为了保证3条路径互不相交， 我们首先要考虑左边的路径向右移动的情况，然后是中间，最后是右边的路径。 为了更好的理解，让我们来考虑左边的路径向右移动的情况，对于每一个可能的j,k对(j&lt;k)， 对每个i(i&lt;j)，考虑从位置(i-1,j,k)移动到位置(i,j,k)。处理完左边的路径， 再处理中间的路径，最后处理右边的路径。方法都差不多。 其它当阅读一个题目并且开始尝试解决它时，首先看一下它的限制。 如果要求在多项式时间内解决，那么该问题就很可能要用DP来解。遇到这种情况， 最重要的就是找到问题的“状态”和“状态转移方程”。(状态不是随便定义的， 一般定义完状态，你要找到当前状态是如何从前面的状态得到的， 即找到状态转移方程)如果看起来是个DP问题，但你却无法定义出状态， 那么试着将问题规约到一个已知的DP问题(正如“高级”一节中的例子一样)。","categories":[{"name":"技术","slug":"技术","permalink":"http://wxy-cs.com/categories/技术/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://wxy-cs.com/tags/算法/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://wxy-cs.com/categories/技术/"}]},{"title":"Dijkstra(迪杰斯特拉)算法","slug":"Dijkstra-迪杰斯特拉-算法","date":"2016-10-10T07:31:18.000Z","updated":"2016-10-10T08:44:42.187Z","comments":true,"path":"2016/10/10/Dijkstra-迪杰斯特拉-算法/","link":"","permalink":"http://wxy-cs.com/2016/10/10/Dijkstra-迪杰斯特拉-算法/","excerpt":"","text":"迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个节点到其它节点的最短路径。 迪杰斯特拉(Dijkstra)算法以起点为中心层层向外扩展（广度优先搜索思想）,直到扩展到终点为止。 原理 首先，引进一个辅助向量D，它的每个分量D表示当前所找到的从始点v到每个终点vi的最短路径的长度。如D[3]=2表示从始点v到终点3的路径相对最小长度为2。这里强调相对就是说在算法过程中D的值是在不断逼近最终结果但在过程中不一定就等于最短路径长度。它的初始状态为：若从v到vi有弧，则D为弧上的权值；否则置D为∞。显然，长度为 D[j]=Min{D | vi∈V} 的路径就是从v出发的长度最短的一条最短路径。此路径为(v,vj)。 那么，下一条长度次短的最短路径是哪一条呢？假设该次短路径的终点是vk，则可想而知，这条路径或者是(v,vk)，或者是(v,vj,vk)。它的长度或者是从v到vk的弧上的权值，或者是D[j]和从vj到vk的弧上的权值之和。 一般情况下，假设S为已求得最短路径的终点的集合，则可证明：下一条最短路径（设其终点为X）或者是弧(v,x)，或者是中间只经过S中的顶点而最后到达顶点X的路径。因此，下一条长度次短的最短路径的长度必是D[j]=Min{D | vi∈V-S} 其中，D或者是弧(v,vi)上的权值，或者是Dk和弧(vk,vi)上的权值之和。 基本思想 通过Dijkstra计算图G中的最短路径时，需要指定起点s(即从顶点s开始计算)。 此外，引进两个集合S和U。S的作用是记录已求出最短路径的顶点(以及相应的最短路径长度)，而U则是记录还未求出最短路径的顶点(以及该顶点到起点s的距离)。 初始时，S中只有起点s；U中是除s之外的顶点，并且U中顶点的路径是”起点s到该顶点的路径”。然后，从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 然后，再从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 … 重复该操作，直到遍历完所有顶点。 图解 动态图解 注：以上图片均来自网络，如有侵权，24小时内删除！","categories":[{"name":"技术","slug":"技术","permalink":"http://wxy-cs.com/categories/技术/"}],"tags":[{"name":"算法,最短路径算法","slug":"算法-最短路径算法","permalink":"http://wxy-cs.com/tags/算法-最短路径算法/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://wxy-cs.com/categories/技术/"}]},{"title":"sql server存储过程和触发器","slug":"sql-server","date":"2016-05-18T11:04:40.000Z","updated":"2016-10-03T11:20:42.223Z","comments":true,"path":"2016/05/18/sql-server/","link":"","permalink":"http://wxy-cs.com/2016/05/18/sql-server/","excerpt":"","text":"存储过程存储过程Procedure是一组为了完成特定功能的SQL语句集合，经编译后存储在数据库中，用户通过指定存储过程的名称并给出参数来执行。 1.系统存储过程","categories":[{"name":"技术","slug":"技术","permalink":"http://wxy-cs.com/categories/技术/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://wxy-cs.com/tags/数据库/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://wxy-cs.com/categories/技术/"}]},{"title":"对多值依赖的理解","slug":"maltivalued-dependence","date":"2016-05-18T10:59:31.000Z","updated":"2016-10-03T11:19:13.051Z","comments":true,"path":"2016/05/18/maltivalued-dependence/","link":"","permalink":"http://wxy-cs.com/2016/05/18/maltivalued-dependence/","excerpt":"","text":"在关系数据库设计中的函数依赖理论中有一个多值依赖，对多值依赖的理解现做如下整理： 搜寻资料发现对多值依赖的讲解无非都用了两个关系模式的例子： 1.Teching（物理，老师，资料） 2.Storehouse（仓库管理员，仓库号，库存产品号） 首先说到多值依赖就会想到函数依赖，函数依赖规定了某些元组不能出现在关系中。如果A-&gt;B成立，我们就不能有两个元组在A上的值相同而在B上的值不同。而多值依赖却可以不排除这些元组的存在，所以函数依赖有时候又叫相等产生的依赖，而多值依赖又叫元组产生的依赖。 多值依赖从名字上看的理解是多个值依赖于同一个值 定义设R（U）是属性集U上的一个关系模式，X，Y，Z是U的子集，并且Z=U-X-Z。关系模式R上X-&gt;-&gt;Y成立，当且仅当对R（U）中的任意一个关系r,给定一对（X，Z）值，有一组Y的值与之对应，这组值仅仅取决于X的值，而与Z的值无关。 看定义很模糊，来看一个例子（来自《数据库系统概念》): ID dept_name street city 22222 Physics North Rye 22222 Physics Main Manchester 12121 Finance Lake Horseneck 是一个大学的关系模型，ID为教师的ID，一个教师有多个地址 我们按照定义来看一下，一个ID值有多个（street,city）与之对应。将ID看成X，将（street，city）看成Y，将dept_name看成Z，Z=U-X-Y,而且给定一组（X,Z）的值（我们选（2222，physics））有一组Y值与之对应（（North,Rye）,(Main,Manchester)）,所以可以说 ID-&gt;-&gt;street city 现在我们再来看一下开头说的两个例子: 例l： 学校中某一门课程由多个教员讲授，他们使用相同的一套参考书。每个教员可以讲授多门课程，每种参考书可以供多门课程使用。我们可以用一个非规范化的关系来表示教员T,课程C和参考书B之间的关系： 课程C 教员T 参考书B-————————————物理 李勇 普通物理学 王 军 光学原理 物理习题集-————————————数学 李 勇 数学分析 张 平 微分方程 高等代数 该关系模式存在全码(C,T,B),因此该关系模式属于BCNF范式 我们再来用多值依赖的定义来看一下这个关系模式：对于一个（物理，光学原理）有一组T值{李勇，王军}与之对应，但这组值仅仅取决于（物理），也就是说对于另一（物理，普通物理学），它对应的这组值仍然是{李勇，王军}，所以{李勇，王军}其实就是Z，物理是X，（普通物理学，光学原理，物理习题集）就是一组Y，C-&gt;-&gt;B成立！ 例2：有这样一个关系 &lt;仓库管理员，仓库号，库存产品号&gt; ，假设一个产品只能放到一个仓库中，但是一个仓库可以有若干管理员。 我们取一个（仓库管理员，仓库号），与之有一组库存产品号与之对应，而与仓库管理员无关，所以仓库号-&gt;-&gt;库存产品号,而这里面也存在仓库号-&gt;-&gt;仓库管理员,而与库存产品号无关。 推论 1.如果将对应一组Y值改为一个Y值，多值依赖就变成函数依赖了，所以可以说函数依赖是特殊的多值依赖。 2.若X-&gt;-&gt;Y，且Z为空集，则称X-&gt;-&gt;Y为平凡的多值依赖,否则称为非平凡的多值依赖。 存在的问题 1.冗余大 2.插入复杂 3.更新复杂 4.删除复杂 性质 1.对称性若X-&gt;-&gt;Y,则X-&gt;-&gt;Z，其中Z=U-X-Y 2.传递性若X-&gt;-&gt;Y, Y-&gt;-&gt;Z,则X-&gt;-&gt;Z 对称性: 参考文献:1.《数据库系统概念》， 杨冬青、李红燕、唐世渭，北京：机械工业出版社，20122.《数据库系统概论》，王珊、萨师煊，北京：高等教育出版社，2014","categories":[{"name":"技术","slug":"技术","permalink":"http://wxy-cs.com/categories/技术/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://wxy-cs.com/tags/数据库/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://wxy-cs.com/categories/技术/"}]}]}